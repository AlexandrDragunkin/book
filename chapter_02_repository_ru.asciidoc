[[chapter_02_repository]]
== Repository Pattern

Пришло время выполнить наше обещание использовать принцип инверсии зависимостей как способ отделить нашу основную логику от инфраструктурных проблем.

((("storage", seealso="repositories; Repository pattern")))
((("Repository pattern")))
((("data storage, Repository pattern and")))
Введем шаблон _Repository_. Штуку упрощающую абстракцию над хранилищем данных, позволяющую нам отделить слой модели от слоя данных. Давайте приведем конкретный пример того, как эта упрощающая абстракция делает нашу систему более тестируемой, скрывая сложности базы данных.

Картина <<maps_chapter_02>> илюстрирует то, что мы собираемся построить: объект `Repository`, который находится между нашей моделью предметной области и базой данных.

[[maps_chapter_02]]
.До и после шаблона репозитория
image::images/apwp_0201.png[]

[TIP]
====
Код для этой главы находится в
chapter_02_repository branch https://oreil.ly/6STDu[on GitHub].

----
git clone https://github.com/cosmicpython/code.git
cd code
git checkout chapter_02_repository
# или чтобы писать код вместе с нами, ознакомьтесь с предыдущей главой:
git checkout chapter_01_domain_model
----
====


=== Persisting Our Domain Model

((("domain model", "persisting")))
В <<chapter_01_domain_model>> мы построили простую модель домена, которая может распределять заказы по партиям запасов. Нам было легко писать тесты для такого кода, потому что нет никаких зависимостей или инфраструктуры для настройки. Если бы нам нужно было запустить базу данных или API и создать тестовые данные, наши тесты было бы сложнее писать и поддерживать.

К сожалению, в какой-то момент нам придется передать нашу идеальную маленькую модель в руки пользователей и бороться с реальным миром электронных таблиц, веб-браузеров и условий гонки. В следующих нескольких главах мы рассмотрим, как связать нашу идеализированную модель предметной области с внешним состоянием.

((("minimum viable product")))
Мы ожидаем, что будем работать гибко, поэтому наш приоритет - как можно быстрее получить минимально жизнеспособный продукт. В нашем случае это будет веб-API. В реальном проекте вы можете сразу погрузиться в несколько сквозных (end-to-end) тестов и начать подключать веб-фреймворк, тестируя функционал извне.

Но мы знаем, что, несмотря ни на что, нам понадобится какая-то форма постоянного хранения. Поскольку это учебник, мы можем позволить себе немного больше развития снизу вверх и начать думать о хранении и базах данных.


=== Некий Псевдокод: Что Нам Понадобится?

Когда мы создаём нашу первый API endpoint, мы знаем, что у нас будет некоторый код, который выглядит более или менее следующим образом.

[[api_endpoint_pseudocode]]
.What our first API endpoint will look like
====
[role="skip"]
[source,python]
----
@flask.route.gubbins
def allocate_endpoint():
    # извлечь строку заказа из запроса
    line = OrderLine(request.params, ...)
    # загрузить все партии из БД
    batches = ...
    # передать в domain service
    allocate(line, batches)
    # затем сохраните выделеные позици обратно в базу данных
    return 201
----
====

NOTE: Мы использовали Flask, потому что он достаточно легкий, но вам не нужно быть пользователем Flask, чтобы понять эту книгу. На самом деле, мы покажем вам, как сделать ваш выбор фреймворка незначительной деталью.
    ((("Flask framework")))

Нам понадобится способ извлечения пакетной информации из базы данных и создания из нее экземпляров объектов модели домена, а также способ сохранения их обратно в базу данных.

_Какого...? Ух-х-х, «gubbins» - это британское слово, означающее «фигня». Вы можете просто забить на это. Это псевдокод, понятно?_


=== Applying the DIP to Data Access

((("layered architecture")))
((("data access, applying dependency inversion principle to")))
Как уже упоминалось в <<введение, введение>>, многоуровневая архитектура -- это общий подход к структурированию системы, которая имеет пользовательский интерфейс, некоторую логику и базу данных (см.
<<layered_architecture2>>).

[role="width-75"]
[[layered_architecture2]]
.Многослойная архитектура
image::images/apwp_0202.png[]


Структура Django Model-View-Template тесно связана, как и Model-View-Controller (MVC). В любом случае цель состоит в том, чтобы слои были разделены (что хорошо), и чтобы каждый слой зависел только от того, который находится под ним.

((("dependencies", "none in domain model")))
Надо, чтобы в нашей модели предметной области не было __ никаких зависимостей __.footnote:[ Полагаю, мы имеем в виду «отсутствие зависимостей с отслеживанием состояния». В зависимости от вспомогательной библиотеки это нормально; в зависимости от ORM или веб-фреймворка -- нет.] Не надо, чтобы проблемы с инфраструктурой проникли в нашу модель предметной области и замедлили наши модульные тесты или нашу способность вносить изменения.

((("onion architecture")))
Вместо этого, как обсуждалось во введении, мы будем думать, что наша модель находится "inside (внутри)", и зависимости текут внутрь неё; это то, что умные люди иногда называют _onion (луковая) architecture_ (см. <<onion_architecture>>).

[role="width-75"]
[[onion_architecture]]
.Onion architecture
image::images/apwp_0203.png[]
[role="image-source"]
----
[ditaa, apwp_0203]
+------------------------+
|   Presentation Layer   |
+------------------------+
           |
           V
+--------------------------------------------------+
|                  Domain Model                    |
+--------------------------------------------------+
                                        ^
                                        |
                             +---------------------+
                             |    Database Layer   |
                             +---------------------+
----

[role="nobreakinside less_space"]
.Это Порты и Адаптеры?
****
Если вы читали об архитектурных паттернах, вы можете задавать себе такие вопросы:

____
_Это порты и адаптеры? Или это гексогональная архитектура? Это то же самое, что и луковая архитектура? А как насчет чистой архитектуры? Что такое порт и что такое адаптер? Почему у вас, яйцеголовых, так много слов для одного и того же?_
____

((("dependency inversion principle")))
((("Seemann, Mark, blog post")))
Хотя некоторые умники любят придираться к различиям, все это в значительной степени названия одного и того же, и все они сводятся к принципу инверсии зависимостей: модули высокого уровня (домен) не должны зависеть от модулей низкого уровня (инфраструктура).footnote:[Mark Seemann has
https://oreil.ly/LpFS9[an excellent blog post] on the topic.]

Мы рассмотрим некоторые мелочи, касающиеся «зависимости от абстракций», и того, существует ли Pythonic-эквивалент интерфейсов,
<<depend_on_abstractions,later in the book>>. Смотрите также <<what_is_a_port_and_what_is_an_adapter>>.
****


=== Напоминание: Наша модель

((("domain model", id="ix_domod")))
Давайте вспомним нашу модель предметной области (см. <<model_diagram_reminder>>):
Распределение - это концепция связывания `OrderLine` с `Batch`. Мы сохраняем выделенные позиици как коллекцию в нашем объекте `Batch`.

[[model_diagram_reminder]]
.Наша модель
image::images/apwp_0103.png[]
// see chapter_01_domain_model for diagram source

Давайте посмотрим, как мы можем перевести это в реляционную базу данных.


==== "Нормальный" способ это ORM: Модель зависит от ORM

((("SQL", "generating for domain model objects")))
((("domain model", "translating to relational database", "normal ORM way, model depends on ORM")))
В наши дни маловероятно, что члены вашей команды вручную создают свои собственные SQL-запросы. Вместо этого вы почти наверняка используете какой-то фреймворк для генерации строк SQL на основе ваших объектов модели.

((("object-relational mappers (ORMs)")))
Эти структуры называются объектно-реляционными картографами _object-relational mappers_ (ОРМ), поскольку они существуют для преодоления концептуального разрыва между миром объектов и моделирования предметной области и миром баз данных и реляционной алгебры.

((("persistence ignorance")))
Самая важная вещь, которую дает нам ORM, - это забить на персистентность _persistence ignorance_: идея о том, что наша модельная доменная модель не должна ничего знать о том, как данные загружаются или сохраняются. Это помогает сохранить наш домен чистым от прямых зависимостей конкретных технологий баз данных.footnote:[В этом смысле использование ORM уже является примером DIP. Вместо того чтобы полагаться на жестко запрограммированный SQL, мы зависим от абстракции, ORM. Но нам этого мало -- не в этой книге!]

((("object-relational mappers (ORMs)", "SQLAlchemy, model depends on ORM")))
((("SQLAlchemy", "declarative syntax, model depends on ORM")))
Но если вы будете следовать типичному учебнику SQLAlchemy, то в итоге получите что-то вроде этого:


[[typical_sqlalchemy_example]]
.SQLAlchemy "декларативный" синтаксис, модель зависит от ORM (orm.py)
====
[role="skip"]
[source,python]
----
from sqlalchemy import Column, ForeignKey, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class Order(Base):
    id = Column(Integer, primary_key=True)

class OrderLine(Base):
    id = Column(Integer, primary_key=True)
    sku = Column(String(250))
    qty = Integer(String(250))
    order_id = Column(Integer, ForeignKey('order.id'))
    order = relationship(Order)

class Allocation(Base):
    ...
----
====

Вам не нужно разбираться в SQLAlchemy, чтобы увидеть, что наша изначальная модель теперь полна зависимостей от ORM и к тому же начинает выглядеть чертовски уродливо. Можно ли сказать, что эта модель игнорирует базу данных? Как это можно отделить от проблем с хранением, когда свойства нашей модели напрямую связаны со столбцами базы данных?

[role="nobreakinside less_space"]
.ORM Django, по сути, тот же, но более ограничительный
****

((("Django", "ORM example")))
((("object-relational mappers (ORMs)", "Django ORM example")))
Если вы больше привыкли к Django, предыдущий «декларативный» фрагмент SQLAlchemy можно перевести примерно так:

[[django_orm_example]]
.Django ORM пример
====
[source,python]
[role="skip"]
----
class Order(models.Model):
    pass

class OrderLine(models.Model):
    sku = models.CharField(max_length=255)
    qty = models.IntegerField()
    order = models.ForeignKey(Order)

class Allocation(models.Model):
    ...
----
====

Дело в том же - наши классы моделей наследуются напрямую от классов ORM, поэтому наша модель зависит от ORM. Мы хотим, чтобы все было наоборот.

Django не предоставляет эквивалента классическому мапперу SQLAlchemy, но примеры применения инверсии зависимостей и шаблона репозитория к Django см. в разделе <<appendix_django>>.

****



==== Инвертирование зависимости: ORM зависит от модели

((("mappers")))
((("classical mapping")))
((("SQLAlchemy", "explicit ORM mapping with SQLAlchemy Table objects")))
((("dependency inversion principle", "ORM depends on the data model")))
((("domain model", "translating to relational database", "ORM depends on the model")))
((("object-relational mappers (ORMs)", "ORM depends on the data model")))
К счастью, это не единственный способ использовать SQLAlchemy. Альтернативой является определение вашей схемы отдельно и определение явного _mapper_ для преобразования между схемой и нашей моделью предметной области, что SQLAlchemy называет
https://oreil.ly/ZucTG[classical mapping]:

[role="nobreakinside less_space"]
[[sqlalchemy_classical_mapper]]
.Явное сопоставление ORM с объектами таблицы SQLAlchemy (orm.py)
====
[source,python]
----
from sqlalchemy.orm import mapper, relationship

import model  #<1>


metadata = MetaData()

order_lines = Table(  #<2>
    'order_lines', metadata,
    Column('id', Integer, primary_key=True, autoincrement=True),
    Column('sku', String(255)),
    Column('qty', Integer, nullable=False),
    Column('orderid', String(255)),
)

...

def start_mappers():
    lines_mapper = mapper(model.OrderLine, order_lines)  #<3>
----
====

<1> ORM импортирует (или "зависит от" или "знает о") модель предметной области, а не наоборот.

<2> Мы определяем таблицы и столбцы нашей базы данных с помощью абстракций SQLAlchemy.footnote:[Даже в проектах, где мы не используем ORM, мы часто используем SQLAlchemy вместе с Alembic для декларативного создания схем в Python и управления миграциями, соединениями и сеансами.]

<3> Когда мы вызываем функцию `mapper`, SQLAlchemy творит чудеса, связывая классы нашей модели предметной области с различными таблицами, которые мы определили.

Конечным результатом будет то, что, если мы вызовем `start_mappers`, мы сможем легко загружать и сохранять экземпляры модели домена из базы данных и в нее. Но если мы никогда не вызываем эту функцию, наши классы доменных моделей остаются в блаженном неведении о базе данных.

// IDEA: add a note about mapper being maybe-deprecated, but link to
// the mailing list post where mike shows how to reimplement it manually.

Это дает нам все преимущества SQLAlchemy, включая возможность использовать `alembic` для миграций и возможность прозрачного запроса с использованием наших классов домена, как мы увидим.

((("object-relational mappers (ORMs)", "ORM depends on the data model", "testing the ORM")))
Когда вы впервые пытаетесь создать свою конфигурацию ORM, может быть полезно написать для неё тесты, как в следующем примере:


[[orm_tests]]
.Тестирование ОРМ напрямую (одноразовые тесты) (test_orm.py)
====
[source,python]
----
def test_orderline_mapper_can_load_lines(session):  #<1>
    session.execute(
        'INSERT INTO order_lines (orderid, sku, qty) VALUES '
        '("order1", "RED-CHAIR", 12),'
        '("order1", "RED-TABLE", 13),'
        '("order2", "BLUE-LIPSTICK", 14)'
    )
    expected = [
        model.OrderLine("order1", "RED-CHAIR", 12),
        model.OrderLine("order1", "RED-TABLE", 13),
        model.OrderLine("order2", "BLUE-LIPSTICK", 14),
    ]
    assert session.query(model.OrderLine).all() == expected


def test_orderline_mapper_can_save_lines(session):
    new_line = model.OrderLine("order1", "DECORATIVE-WIDGET", 12)
    session.add(new_line)
    session.commit()

    rows = list(session.execute('SELECT orderid, sku, qty FROM "order_lines"'))
    assert rows == [("order1", "DECORATIVE-WIDGET", 12)]
----
====

<1> Если вы не использовали pytest, то аргумент `session` для этого теста нуждается в объяснении. Вам не нужно беспокоиться о деталях pytest или его фикстурах для целей этой книги, но краткое объяснение состоит в том, что вы можете определить общие зависимости для ваших тестов как "fixtures", и pytest введет их в тесты, которые нуждаются в них, посмотрев на их аргументы функций. В данном случае это сеанс базы данных SQLAlchemy.
    ((("pytest", "session argument")))

////
[SG] Я настроил conftest на сеанс и мог заставить тесты работать только в том случае, если я сбросил (frozen=True) на dataclass OrderLine, иначе я получил бы dataclasses.FrozenInstanceError: не могу назначить поле '_sa_instance_state', я чувствую, что мне приходится довольно много работать, чтобы следовать за ним ;-(.

Не является ли изложение всего намеренной тактикой, чтобы заставить читателя учиться?
////

Вероятно, вы бы не стали хранить эти тесты -- как вы вскоре увидите, после того, как вы сделаете шаг по инверсии зависимости ORM и модели предметной области, это всего лишь небольшой дополнительный шаг для реализации другой абстракции, называемой шаблоном репозитория, против которого будет легче писать тесты, и он предоставит простой интерфейс для , скажем так -- обмана, позже в тестах.

Но мы уже достигли нашей цели инвертировать традиционную зависимость: модель предметной области остается «чистой» и свободной от инфраструктурных проблем. Мы могли бы выбросить SQLAlchemy и использовать другую ORM или совершенно другую систему сохранения, и модель предметной области вообще не нуждалась бы в изменении.


В зависимости от того, что вы делаете в своей модели предметной области, и особенно если вы отходите далеко от парадигмы объектно-ориентированного программирования, вам может оказаться все труднее заставить ORM обеспечить точное поведение, которое вам нужно, и вам может потребоваться изменить модель предметной области.footnote: [Привет чрезвычайно полезным специалистам по сопровождению SQLAlchemy и, в частности, Майку Байеру.] Как это часто бывает с архитектурными решениями, вам нужно будет найти компромисс. Как говорит дзэн Python: «Практичность лучше чистоты!»

((("SQLAlchemy", "using directly in API endpoint")))
На данный момент, однако, наша конечная точка API может выглядеть примерно так, и мы могли бы заставить ее работать просто отлично:

[[api_endpoint_with_session]]
.Использование SQLAlchemy непосредственно в нашей конечной точке API
====
[role="skip"]
[source,python]
----
@flask.route.gubbins
def allocate_endpoint():
    session = start_session()

    # извлечение строки заказа из запроса
    line = OrderLine(
        request.json['orderid'],
        request.json['sku'],
        request.json['qty'],
    )

    # загрузите все пакеты из БД
    batches = session.query(Batch).all()

    # call our domain service
    allocate(line, batches)

    # сохраните распределения обратно в базу данных
    session.commit()

    return 201
----
====

////
[SG] из того, что я помню из предыдущего кода, если ни один из пакетов не can_allocate, тогда этот allocate(line, batches) вызовет OutOfStock.  Это нормально позволить этому пузырю подняться?  Если вы добавите попытку, наконец, закрыть сеанс
////

=== Знакомство с шаблоном репозитория

((("Repository pattern", id="ix_Repo")))
((("domain model", startref="ix_domod")))
Шаблон _Repository_ -- это абстракция над постоянным хранилищем. Он скрывает скучные детали доступа к данным, делая вид, что все наши данные находятся в памяти.

Если бы у нас была бесконечная память в наших ноутбуках, у нас не было бы необходимости в неуклюжих базах данных. Вместо этого мы могли просто использовать наши объекты, когда нам заблагорассудится. Как это будет выглядеть?

[[all_my_data]]
.Вы должны откуда-то брать данные
====
[role="skip"]
[source,python]
----
import all_my_data

def create_a_batch():
    batch = Batch(...)
    all_my_data.batches.add(batch)

def modify_a_batch(batch_id, new_quantity):
    batch = all_my_data.batches.get(batch_id)
    batch.change_initial_quantity(new_quantity)

----
====


Несмотря на то, что наши объекты находятся в памяти, нам нужно поместить их где-нибудь, чтобы снова найти их. Наши данные в памяти позволят нам добавлять новые объекты, как список или множество. Поскольку объекты находятся в памяти, нам никогда не нужно вызывать метод `.save ()`; мы просто получаем объект, который нам нужен, и модифицируем его в памяти.


==== The Repository in the Abstract

((("Repository pattern", "simplest possible repository")))
((("Unit of Work pattern")))
В простейшем репозитории всего два метода: add () для добавления нового элемента в репозиторий и get() для возврата ранее добавленного элемента.footnote:[ Вы можете подумать: «А как насчет `list`, `delete` или `update`?" Однако в идеальном мире мы модифицируем объекты нашей модели по одному, а удаление обычно обрабатывается как мягкое удаление, то есть `batch.cancel ()`. Наконец, об обновлении позаботится шаблон Unit of Work, как вы увидите в <<chapter_06_uow>>.]
Мы твердо придерживаемся использования этих методов для доступа к данным в нашем домене и на уровне сервиса. Эта добровольная простота не позволяет нам связать нашу модель предметной области с базой данных.

((("abstract base classes (ABCs)", "ABC for the repository")))
Вот как будет выглядеть абстрактный базовый класс (ABC) для нашего репозитория:

[[abstract_repo]]
.Самый простой из возможных репозиториев (repository.py)
====
[source,python]
----
class AbstractRepository(abc.ABC):

    @abc.abstractmethod  #<1>
    def add(self, batch: model.Batch):
        raise NotImplementedError  #<2>

    @abc.abstractmethod
    def get(self, reference) -> model.Batch:
        raise NotImplementedError
----
====


<1> Python tip: `@abc.abstractmethod` -- это одна из немногих вещей, которая заставляет ABCs действительно "работать" в Python. Python не позволит вам создать экземпляр класса, который не реализует все "абстрактные методы", определенные в его родительском классе.footnote:[Чтобы действительно воспользоваться преимуществами ABC (какими бы они ни были), запустите помощники, такие как `pylint` и `mypy`.]
    ((("@abc.abstractmethod")))
    ((("abstract methods")))

<2> `raise NotImplementedError` -- это хорошо, но это не обязательно и не достаточно. На самом деле, ваши абстрактные методы могут иметь реальное поведение, которое подклассы могут вызвать, если вы действительно хотите.

[role="pagebreak-before less_space"]
.Абстрактные базовые классы, Утиная типизация и Протоколы
*******************************************************************************

((("abstract base classes (ABCs)", "using duck typing and protocols instead of")))
((("protocols, abstract base classes, duck typing, and")))
Мы используем абстрактные базовые классы в этой книге по дидактическим соображениям: мы надеемся, что они помогут объяснить, что такое интерфейс абстракции репозитория.

((("duck typing")))
В реальной жизни мы иногда обнаруживаем, что удаляем ABC из нашего продакшен кода, потому что Python слишком упрощает их игнорирование, и они в конечном итоге не обслуживаются и, в худшем случае, вводят в заблуждение. На практике мы часто просто полагаемся на утиную типизацию Python для включения абстракций. Для Pythonista репозиторий -- это _ любой_ объект, имеющий pass:[<code>add(<em>thing</em>)</code>] and pass:[<code>get(<em>id</em>)</code>] methods.

((("PEP 544 protocols")))
Альтернативой для изучения является https://oreil.ly/q9EPC [протоколы PEP 544]. Это дает вам возможность печатать без возможности наследования, что особенно понравится фанатам "предпочитать композицию наследованию".

*******************************************************************************


==== Что такое компромисс?


[цитата, Рич Хикки]
____
Вы знаете, они говорят, что экономисты знают цену всему и ничего не ценят? Ну, программисты знают о преимуществах и ничего о компромисах.
____

((("Repository pattern", "trade-offs")))
Whenever we introduce an architectural pattern in this book, we'll always
ask, "What do we get for this?  And what does it cost us?"

Usually, at the very least, we'll be introducing an extra layer of abstraction,
and although we may hope it will reduce complexity overall, it does add
complexity locally, and it has a cost in terms of the raw numbers of moving parts and
ongoing maintenance.

The Repository pattern is probably one of the easiest choices in the book, though,
if you're already heading down the DDD and dependency inversion route.  As far
as our code is concerned, we're really just swapping the SQLAlchemy abstraction
(`session.query(Batch)`) for a different one (`batches_repo.get`) that we
designed.

We will have to write a few lines of code in our repository class each time we
add a new domain object that we want to retrieve, but in return we get a
simple abstraction over our storage layer, which we control. The Repository pattern would make
it easy to make fundamental changes to the way we store things (see
<<appendix_csvs>>), and as we'll see, it is easy to fake out for unit tests.

((("domain driven design (DDD)", "Repository pattern and")))
In addition, the Repository pattern is so common in the DDD world that, if you
do collaborate with programmers who have come to Python from the Java and C#
worlds, they're likely to recognize it. <<repository_pattern_diagram>> illustrates the pattern.

[role="width-60"]
[[repository_pattern_diagram]]
.Repository pattern
image::images/apwp_0205.png[]
[role="image-source"]
----
[ditaa, apwp_0205]
  +-----------------------------+
  |      Application Layer      |
  +-----------------------------+
                 |^
                 ||          /------------------\
                 ||----------|   Domain Model   |
                 ||          |      Objects     |
                 ||          \------------------/
                 V|
  +------------------------------+
  |          Repository          |
  +------------------------------+
                 |
                 V
  +------------------------------+
  |        Database Layer        |
  +------------------------------+
----


((("Repository pattern", "testing the  repository with saving an object")))
((("SQL", "repository test for saving an object")))
As always, we start with a test. This would probably be classified as an
integration test, since we're checking that our code (the repository) is
correctly integrated with the database; hence, the tests tend to mix
raw SQL with calls and assertions on our own code.

TIP: Unlike the ORM tests from earlier, these tests are good candidates for
    staying part of your codebase longer term, particularly if any parts of
    your domain model mean the object-relational map is nontrivial.


[[repo_test_save]]
.Repository test for saving an object (test_repository.py)
====
[source,python]
----
def test_repository_can_save_a_batch(session):
    batch = model.Batch("batch1", "RUSTY-SOAPDISH", 100, eta=None)

    repo = repository.SqlAlchemyRepository(session)
    repo.add(batch)  #<1>
    session.commit()  #<2>

    rows = list(session.execute(
        'SELECT reference, sku, _purchased_quantity, eta FROM "batches"'  #<3>
    ))
    assert rows == [("batch1", "RUSTY-SOAPDISH", 100, None)]
----
====

<1> `repo.add()` is the method under test here.

<2> We keep the `.commit()` outside of the repository and make
    it the responsibility of the caller. There are pros and cons for
    this; some of our reasons will become clearer when we get to
    <<chapter_06_uow>>.

<3> We use the raw SQL to verify that the right data has been saved.

((("SQL", "repository test for retrieving complex object")))
((("Repository pattern", "testing the repository with retrieving a complex object")))
The next test involves retrieving batches and allocations, so it's more
complex:


[[repo_test_retrieve]]
.Repository test for retrieving a complex object (test_repository.py)
====
[source,python]
----
def insert_order_line(session):
    session.execute(  #<1>
        'INSERT INTO order_lines (orderid, sku, qty)'
        ' VALUES ("order1", "GENERIC-SOFA", 12)'
    )
    [[orderline_id]] = session.execute(
        'SELECT id FROM order_lines WHERE orderid=:orderid AND sku=:sku',
        dict(orderid="order1", sku="GENERIC-SOFA")
    )
    return orderline_id

def insert_batch(session, batch_id):  #<2>
    ...

def test_repository_can_retrieve_a_batch_with_allocations(session):
    orderline_id = insert_order_line(session)
    batch1_id = insert_batch(session, "batch1")
    insert_batch(session, "batch2")
    insert_allocation(session, orderline_id, batch1_id)  #<2>

    repo = repository.SqlAlchemyRepository(session)
    retrieved = repo.get("batch1")

    expected = model.Batch("batch1", "GENERIC-SOFA", 100, eta=None)
    assert retrieved == expected  # Batch.__eq__ only compares reference  #<3>
    assert retrieved.sku == expected.sku  #<4>
    assert retrieved._purchased_quantity == expected._purchased_quantity
    assert retrieved._allocations == {  #<4>
        model.OrderLine("order1", "GENERIC-SOFA", 12),
    }
----
====


<1> This tests the read side, so the raw SQL is preparing data to be read
    by the `repo.get()`.

<2> We'll spare you the details of `insert_batch` and `insert_allocation`;
    the point is to create a couple of batches, and, for the
    batch we're interested in, to have one existing order line allocated to it.

<3> And that's what we verify here. The first `assert ==` checks that the
    types match, and that the reference is the same (because, as you remember,
    `Batch` is an entity, and we have a custom ++__eq__++ for it).

<4> So we also explicitly check on its major attributes, including
    `._allocations`, which is a Python set of `OrderLine` value objects.

((("Repository pattern", "typical repository")))
Whether or not you painstakingly write tests for every model is a judgment
call. Once you have one class tested for create/modify/save, you might be
happy to go on and do the others with a minimal round-trip test, or even nothing
at all, if they all follow a similar pattern. In our case, the ORM config
that sets up the `._allocations` set is a little complex, so it merited a
specific test.


You end up with something like this:


[[batch_repository]]
.A typical repository (repository.py)
====
[source,python]
----
class SqlAlchemyRepository(AbstractRepository):

    def __init__(self, session):
        self.session = session

    def add(self, batch):
        self.session.add(batch)

    def get(self, reference):
        return self.session.query(model.Batch).filter_by(reference=reference).one()

    def list(self):
        return self.session.query(model.Batch).all()
----
====


((("Flask framework", "API endpoint")))
((("Repository pattern", "using repository directly in API endpoint")))
((("APIs", "using repository directly in API endpoint")))
And now our Flask endpoint might look something like the following:

[[api_endpoint_with_repo]]
.Using our repository directly in our API endpoint
====
[role="skip"]
[source,python]
----
@flask.route.gubbins
def allocate_endpoint():
    batches = SqlAlchemyRepository.list()
    lines = [
        OrderLine(l['orderid'], l['sku'], l['qty'])
         for l in request.params...
    ]
    allocate(lines, batches)
    session.commit()
    return 201
----
====

[role="nobreakinside less_space"]
.Exercise for the Reader
******************************************************************************

((("SQL", "ORM and Repository pattern as abstractions in front of")))
((("Repository pattern", "ORMs and")))
((("object-relational mappers (ORMs)", "Repository pattern and")))
We bumped into a friend at a DDD conference the other day who said, "I haven't
used an ORM in 10 years." The Repository pattern and an ORM both act as abstractions
in front of raw SQL, so using one behind the other isn't really necessary.  Why
not have a go at implementing our repository without using the ORM? You'll find the code https://github.com/cosmicpython/code/tree/chapter_02_repository_exercise[on GitHub].

We've left the repository tests, but figuring out what SQL to write is up
to you. Perhaps it'll be harder than you think; perhaps it'll be easier.
But the nice thing is, the rest of your application just doesn't care.

******************************************************************************


=== Building a Fake Repository for Tests Is Now Trivial!

((("Repository pattern", "building fake repository for tests")))
((("set, fake repository as wrapper around")))
Here's one of the biggest benefits of the Repository pattern:


[[fake_repository]]
.A simple fake repository using a set (repository.py)
====
[role="skip"]
[source,python]
----
class FakeRepository(AbstractRepository):

    def __init__(self, batches):
        self._batches = set(batches)

    def add(self, batch):
        self._batches.add(batch)

    def get(self, reference):
        return next(b for b in self._batches if b.reference == reference)

    def list(self):
        return list(self._batches)
----
====

Because it's a simple wrapper around a `set`, all the methods are one-liners.

Using a fake repo in tests is really easy, and we have a simple
abstraction that's easy to use and reason about:

[[fake_repository_example]]
.Example usage of fake repository (test_api.py)
====
[role="skip"]
[source,python]
----
fake_repo = FakeRepository([batch1, batch2, batch3])
----
====

You'll see this fake in action in the next chapter.


TIP: Building fakes for your abstractions is an excellent way to get design
    feedback: if it's hard to fake, the abstraction is probably too
    complicated.


[[what_is_a_port_and_what_is_an_adapter]]
=== What Is a Port and What Is an Adapter, in Python?

((("ports", "defined")))
((("adapters", "defined")))
We don't want to dwell on the terminology too much here because the main thing
we want to focus on is dependency inversion, and the specifics of the
technique you use don't matter too much. Also, we're aware that different
people use slightly different definitions.

Ports and adapters came out of the OO world, and the definition we hold onto
is that the _port_ is the _interface_ between our application and whatever
it is we wish to abstract away, and the _adapter_ is the _implementation_
behind that interface or abstraction.

((("interfaces, Python and")))
((("duck typing", "for ports")))
((("abstract base classes (ABCs)", "using for ports")))
Now Python doesn't have interfaces per se, so although it's usually easy to
identify an adapter, defining the port can be harder. If you're using an
abstract base class, that's the port. If not, the port is just the duck type
that your adapters conform to and that your core application expects—the
function and method names in use, and their argument names and types.

Concretely, in this chapter, `AbstractRepository` is the port, and
`SqlAlchemyRepository` and `FakeRepository` are the adapters.



=== Wrap-Up

((("Repository pattern", "and persistence ignorance, trade-offs")))
((("persistence ignorance", "trade-offs")))
Bearing the Rich Hickey quote in mind, in each chapter we
summarize the costs and benefits of each architectural pattern we introduce.
We want to be clear that we're not saying every single application needs
to be built this way; only sometimes does the complexity of the app and domain
make it worth investing the time and effort in adding these extra layers of
indirection. 

With that in mind, <<chapter_02_repository_tradeoffs>> shows
some of the pros and cons of the Repository pattern and our persistence-ignorant
model.

////
[SG] is it worth mentioning that the repository is specifically intended for add and get
of our domain model objects, rather than something used to add and get any old data
which you might call a DAO. Repository is more close to the business domain.
////

[[chapter_02_repository_tradeoffs]]
[options="header"]
.Repository pattern and persistence ignorance: the trade-offs
|===
|Pros|Cons
a|
* We have a simple interface between persistent storage and our domain model.

* It's easy to make a fake version of the repository for unit testing, or to
  swap out different storage solutions, because we've fully decoupled the model
  from infrastructure concerns.

* Writing the domain model before thinking about persistence helps us focus on
  the business problem at hand. If we ever want to radically change our approach,
  we can do that in our model, without needing to worry about foreign keys
  or migrations until later.

* Our database schema is really simple because we have complete control over
  how we map our objects to tables.

a|
* An ORM already buys you some decoupling. Changing foreign keys might be hard,
  but it should be pretty easy to swap between MySQL and Postgres if you
  ever need to.

////
[KP] I always found this benefit of ORMs rather weak. In the rare cases when I
actually had to switch DB engines, the payoff was high enough to justify some
additional work. Also, if you are using "interesting" DB features (say: special
Postgres fields) you usually lose the portability.
////


* Maintaining ORM mappings by hand requires extra work and extra code.

* Any extra layer of indirection always increases maintenance costs and
  adds a "WTF factor" for Python programmers who've never seen the Repository pattern
  before.
|===

<<domain_model_tradeoffs_diagram>> shows the basic thesis: yes, for simple
cases, a decoupled domain model is harder work than a simple ORM/ActiveRecord
pattern.footnote:[Diagram inspired by a post called
https://oreil.ly/fQXkP["Global Complexity, Local Simplicity"] by Rob Vens.]

TIP: If your app is just a simple CRUD (create-read-update-delete) wrapper
    around a database, then you don't need a domain model or a repository.

((("domain model", "trade-offs as a diagram")))
((("Vens, Rob")))
((("&quot;Global Complexity, Local Simplicity&quot; post", primary-sortas="Global")))
But the more complex the domain, the more an investment in freeing
yourself from infrastructure concerns will pay off in terms of the ease of
making changes.


[[domain_model_tradeoffs_diagram]]
.Domain model trade-offs as a diagram
image::images/apwp_0206.png[]


Our example code isn't complex enough to give more than a hint of what
the right-hand side of the graph looks like, but the hints are there.
Imagine, for example, if we decide one day that we want to change allocations
to live on the `OrderLine` instead of on the `Batch` object: if we were using
Django, say, we'd have to define and think through the database migration
before we could run any tests. As it is, because our model is just plain
old Python objects, we can change a `set()` to being a new attribute, without
needing to think about the database until later.

[role="nobreakinside"]
.Repository Pattern Recap
*****************************************************************
Apply dependency inversion to your ORM::
    Our domain model should be free of infrastructure concerns,
    so your ORM should import your model, and not the other way
    around.
    ((("Repository pattern", "recap of important points")))

The Repository pattern is a simple abstraction around permanent storage::
    The repository gives you the illusion of a collection of in-memory
    objects. It makes it easy to create a `FakeRepository` for
    testing and to swap fundamental details of your
    infrastructure without disrupting your core application. See
    <<appendix_csvs>> for an example.
*****************************************************************

You'll be wondering, how do we instantiate these repositories, fake or
real? What will our Flask app actually look like? You'll find out in the next
exciting installment, <<chapter_04_service_layer,the Service Layer pattern>>.

But first, a brief digression.
((("Repository pattern", startref="ix_Repo")))
