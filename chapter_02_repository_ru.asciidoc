[[chapter_02_repository]]
== Repository Pattern

Пришло время выполнить обещание использовать принцип инверсии зависимостей как способ отделить основную логику от инфраструктурных проблем.

((("storage", seealso="repositories; Repository pattern")))
((("Repository pattern")))
((("data storage, Repository pattern and")))
Представляем вам шаблон _Repository_, он упрощает абстракцию над хранилищем данных, позволяющую нам отделить слой модели от слоя данных. Давайте приведем конкретный пример того, как эта упрощающая абстракция делает нашу систему более тестируемой, скрывая сложности базы данных.

Картина <<maps_chapter_02>> илюстрирует то, что мы собираемся построить: объект `Repository`, который находится между нашей моделью предметной области и базой данных.

[[maps_chapter_02]]
.До и после шаблона репозитория
image::images/apwp_0201.png[]

[TIP]
====
Код для этой главы находится в
chapter_02_repository branch https://oreil.ly/6STDu[on GitHub].

----
git clone https://github.com/cosmicpython/code.git
cd code
git checkout chapter_02_repository
# или чтобы писать код вместе с нами, ознакомьтесь с предыдущей главой:
git checkout chapter_01_domain_model
----
====


=== Persisting Our Domain Model

((("domain model", "persisting")))
В <<chapter_01_domain_model>> мы построили простую модель домена, которая может распределять заказы по партиям запасов. Мы относительно легко написали тесты для такого кода, потому что нет никаких зависимостей или инфраструктуры для настройки. Если бы нужно было запустить базу данных или API и создать тестовые данные, тесты было бы сложнее писать и поддерживать.

К сожалению, в какой-то момент нам придется передать эту идеальную маленькую модель в руки пользователей и бороться с реальным миром электронных таблиц, веб-браузеров и условий гонки. В следующих нескольких главах мы рассмотрим, как связать идеализированную модель предметной области с внешним состоянием.

((("minimum viable product")))
В надежде на то, что мы будем работать гибко, наш основной приоритет -- как можно быстрее получить минимально жизнеспособный продукт. В нашем случае это будет веб-API. В реальном проекте вы можете сразу погрузиться в несколько сквозных (end-to-end) тестов и начать подключать веб-фреймворк, тестируя функционал извне.

Но мы знаем, что, несмотря ни на что, нам понадобится какая-то форма постоянного хранения. Поскольку это учебник, мы можем позволить себе немного больше развития снизу вверх и начать думать о хранении и базах данных.


=== Псевдокод: Что делать то будем?

Когда мы создаём наш первый endpoint API, подразумеваем, что у нас будет некоторый код, который выглядит более или менее похожим на этот.

[[api_endpoint_pseudocode]]
.Как будет выглядеть наш первый endpoint API
====
[role="skip"]
[source,python]
----
@flask.route.gubbins
def allocate_endpoint():
    # извлечь строку заказа из запроса
    line = OrderLine(request.params, ...)
    # загрузить все партии из БД
    batches = ...
    # передать в domain service
    allocate(line, batches)
    # затем сохраните выделеные позици обратно в базу данных
    return 201
----
====

NOTE: Мы использовали Flask, потому что он достаточно простой, но вам не нужно быть с Flask на "ты", чтобы понять эту книгу. На самом деле, наша задача объяснить, как сделать выбор фреймворка незначительной деталью.
    ((("Flask framework")))

Нам понадобится способ извлечения пакетной информации из базы данных и создания из нее экземпляров объектов модели домена, а также способ сохранения их обратно в базу данных.

_Какого...? Ух-х-х, «gubbins» - это британское слово, означающее «фигня». Вы можете просто забить на это. Это'ж псевдокод, понятно?_


=== Применение DIP для доступа к данным

((("layered architecture")))
((("data access, applying dependency inversion principle to")))
Как уже упоминалось в <<введение, введение>>, многоуровневая архитектура -- это общий подход к структурированию системы, которая имеет пользовательский интерфейс, некоторую логику и базу данных (см.
<<layered_architecture2>>).

[role="width-75"]
[[layered_architecture2]]
.Многослойная архитектура
image::images/apwp_0202.png[]


Структура Django Model-View-Template тесно связана, как и Model-View-Controller (MVC). В любом случае цель состоит в том, чтобы слои были разделены (что хорошо), и чтобы каждый слой зависел только от того, который находится под ним.

((("dependencies", "none in domain model")))
Надо, чтобы в нашей модели предметной области не было __ никаких зависимостей __.footnote:[ Полагаю, мы имеем в виду «отсутствие зависимостей с отслеживанием состояния». В зависимости от вспомогательной библиотеки это нормально; в зависимости от ORM или веб-фреймворка -- нет.] Не надо, чтобы проблемы с инфраструктурой проникли в нашу модель предметной области и замедлили наши модульные тесты или нашу способность вносить изменения.

((("onion architecture")))
Вместо этого, как обсуждалось во введении, мы будем думать, что наша модель находится "inside (внутри)", и зависимости текут внутрь неё; это то, что умные люди иногда называют _onion (луковая) architecture_ (см. <<onion_architecture>>).

[role="width-75"]
[[onion_architecture]]
.Onion architecture
image::images/apwp_0203.png[]
[role="image-source"]
----
[ditaa, apwp_0203]
+------------------------+
|   Presentation Layer   |
+------------------------+
           |
           V
+--------------------------------------------------+
|                  Domain Model                    |
+--------------------------------------------------+
                                        ^
                                        |
                             +---------------------+
                             |    Database Layer   |
                             +---------------------+
----

[role="nobreakinside less_space"]
.Это Порты и Адаптеры?
****
Если вы читали об архитектурных паттернах, вы можете задавать себе такие вопросы:

____
_Это порты и адаптеры? Или это гексогональная архитектура? Это то же самое, что и луковая архитектура? А как насчет чистой архитектуры? Что такое порт и что такое адаптер? Почему у вас, "яйцеголовых", так много слов для одного и того же?_
____

((("dependency inversion principle")))
((("Seemann, Mark, blog post")))
Хотя некоторые умники любят придираться к различиям, все это в значительной степени названия одного и того же, и все они сводятся к принципу инверсии зависимостей: модули высокого уровня (домен) не должны зависеть от модулей низкого уровня (инфраструктура).footnote:[Mark Seemann has
https://oreil.ly/LpFS9[an excellent blog post] on the topic.]

Мы рассмотрим некоторые мелочи, касающиеся «зависимости от абстракций», и того, существует ли Pythonic-эквивалент интерфейсов,
<<depend_on_abstractions,later in the book>>. Смотрите также <<what_is_a_port_and_what_is_an_adapter>>.
****


=== Напоминание: Наша модель

((("domain model", id="ix_domod")))
Давайте вспомним нашу модель предметной области (см. <<model_diagram_reminder>>):
Распределение - это концепция связывания `OrderLine` с `Batch`. Мы сохраняем выделенные позиици как коллекцию в нашем объекте `Batch`.

[[model_diagram_reminder]]
.Наша модель
image::images/apwp_0103.png[]
// see chapter_01_domain_model for diagram source

Давайте посмотрим, как мы можем перенести это в реляционную базу данных.


==== "Нормальный" способ это ORM: Модель зависит от ORM

((("SQL", "generating for domain model objects")))
((("domain model", "translating to relational database", "normal ORM way, model depends on ORM")))
В наши дни маловероятно, что члены вашей команды вручную создают свои собственные SQL-запросы. Вместо этого вы почти наверняка используете какой-то фреймворк для генерации строк SQL на основе ваших объектов модели.

((("object-relational mappers (ORMs)")))
Эти структуры называются объектно-реляционными картографами _object-relational mappers_ (ОРМ), поскольку они существуют для преодоления концептуального разрыва между миром объектов и моделирования предметной области и миром баз данных и реляционной алгебры.

((("persistence ignorance")))
Самая важная вещь, которую дает нам ORM, - это игнорирование сохраняемости _persistence ignorance_: идея в том, что наша доменная модель не должна ничего знать о том, как данные загружаются или сохраняются. Это помогает сохранить наш домен чистым от прямых зависимостей конкретных технологий баз данных.footnote:[В этом смысле использование ORM уже является примером DIP. Вместо того чтобы полагаться на жестко запрограммированный SQL, мы зависим от абстракции, ORM. Но нам этого мало -- не в этой книге!]

((("object-relational mappers (ORMs)", "SQLAlchemy, model depends on ORM")))
((("SQLAlchemy", "declarative syntax, model depends on ORM")))
Но если вы будете следовать типичному учебнику SQLAlchemy, то в итоге получите что-то вроде этого:


[[typical_sqlalchemy_example]]
.SQLAlchemy "декларативный" синтаксис, модель зависит от ORM (orm.py)
====
[role="skip"]
[source,python]
----
from sqlalchemy import Column, ForeignKey, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class Order(Base):
    id = Column(Integer, primary_key=True)

class OrderLine(Base):
    id = Column(Integer, primary_key=True)
    sku = Column(String(250))
    qty = Integer(String(250))
    order_id = Column(Integer, ForeignKey('order.id'))
    order = relationship(Order)

class Allocation(Base):
    ...
----
====

Вам не нужно разбираться в SQLAlchemy, чтобы увидеть, что наша изначальная модель теперь полна зависимостей от ORM и к тому же начинает выглядеть чертовски уродливо. Можно ли сказать, что эта модель игнорирует базу данных? Как это можно отделить от проблем с хранением, когда свойства нашей модели напрямую связаны со столбцами базы данных?

[role="nobreakinside less_space"]
.ORM Django, по сути, тот же, но более строгий
****

((("Django", "ORM example")))
((("object-relational mappers (ORMs)", "Django ORM example")))
Если вы больше привыкли к Django, предыдущий «декларативный» фрагмент SQLAlchemy можно перевести примерно так:

[[django_orm_example]]
.Django ORM пример
====
[source,python]
[role="skip"]
----
class Order(models.Model):
    pass

class OrderLine(models.Model):
    sku = models.CharField(max_length=255)
    qty = models.IntegerField()
    order = models.ForeignKey(Order)

class Allocation(models.Model):
    ...
----
====

Дело в том же - наши классы моделей наследуются напрямую от классов ORM, поэтому наша модель зависит от ORM. Мы хотим, чтобы все было наоборот.

Django не предоставляет эквивалента классическому мапперу SQLAlchemy, но примеры применения инверсии зависимостей и шаблона репозитория к Django см. в разделе <<appendix_django>>.

****



==== Инвертирование зависимости: ORM зависит от модели

((("mappers")))
((("classical mapping")))
((("SQLAlchemy", "explicit ORM mapping with SQLAlchemy Table objects")))
((("dependency inversion principle", "ORM depends on the data model")))
((("domain model", "translating to relational database", "ORM depends on the model")))
((("object-relational mappers (ORMs)", "ORM depends on the data model")))
К счастью, это не единственный способ использовать SQLAlchemy. Альтернативой является определение вашей схемы отдельно и определение явного _mapper_-а для преобразования между схемой и нашей моделью предметной области, что SQLAlchemy называет
https://oreil.ly/ZucTG[classical mapping]:

[role="nobreakinside less_space"]
[[sqlalchemy_classical_mapper]]
.Явное сопоставление ORM с объектами таблицы SQLAlchemy (orm.py)
====
[source,python]
----
from sqlalchemy.orm import mapper, relationship

import model  #<1>


metadata = MetaData()

order_lines = Table(  #<2>
    'order_lines', metadata,
    Column('id', Integer, primary_key=True, autoincrement=True),
    Column('sku', String(255)),
    Column('qty', Integer, nullable=False),
    Column('orderid', String(255)),
)

...

def start_mappers():
    lines_mapper = mapper(model.OrderLine, order_lines)  #<3>
----
====

<1> ORM импортирует (или "зависит от" или "знает о") модель предметной области, а не наоборот.

<2> Мы определяем таблицы и столбцы нашей базы данных с помощью абстракций SQLAlchemy.footnote:[Даже в проектах, где мы не используем ORM, мы часто используем SQLAlchemy вместе с Alembic для декларативного создания схем в Python и управления миграциями, соединениями и сеансами.]

<3> Когда мы вызываем функцию `mapper`, SQLAlchemy творит чудеса, связывая классы нашей модели предметной области с различными таблицами, которые мы определили.

Конечным результатом будет то, что, если мы вызовем `start_mappers`, мы сможем легко загружать и сохранять экземпляры модели домена из базы данных и в нее. Но если мы никогда не вызываем эту функцию, наши классы доменных моделей остаются в блаженном неведении о базе данных.

// IDEA: add a note about mapper being maybe-deprecated, but link to
// the mailing list post where mike shows how to reimplement it manually.

Это дает нам все преимущества SQLAlchemy, включая возможность использовать `alembic` для миграций и возможность прозрачного запроса с использованием наших классов домена, как мы увидим.

((("object-relational mappers (ORMs)", "ORM depends on the data model", "testing the ORM")))
Когда вы впервые пытаетесь создать свою конфигурацию ORM, может быть полезно написать для неё тесты, как в следующем примере:


[[orm_tests]]
.Тестирование ОРМ напрямую (одноразовые тесты) (test_orm.py)
====
[source,python]
----
def test_orderline_mapper_can_load_lines(session):  #<1>
    session.execute(
        'INSERT INTO order_lines (orderid, sku, qty) VALUES '
        '("order1", "RED-CHAIR", 12),'
        '("order1", "RED-TABLE", 13),'
        '("order2", "BLUE-LIPSTICK", 14)'
    )
    expected = [
        model.OrderLine("order1", "RED-CHAIR", 12),
        model.OrderLine("order1", "RED-TABLE", 13),
        model.OrderLine("order2", "BLUE-LIPSTICK", 14),
    ]
    assert session.query(model.OrderLine).all() == expected


def test_orderline_mapper_can_save_lines(session):
    new_line = model.OrderLine("order1", "DECORATIVE-WIDGET", 12)
    session.add(new_line)
    session.commit()

    rows = list(session.execute('SELECT orderid, sku, qty FROM "order_lines"'))
    assert rows == [("order1", "DECORATIVE-WIDGET", 12)]
----
====

<1> Если вы не использовали pytest, то аргумент `session` для этого теста нуждается в объяснении. Смысл такой: Вам не нужно беспокоиться о деталях pytest или его фикстурах в целях этой книги, но главная мысль состоит в том, что вы можете определить общие зависимости для ваших тестов в виде "fixtures", и pytest передаст их в тесты, которые нуждаются в них, приняв их в качестве аргументов функций. В данном случае это сеанс `session` базы данных SQLAlchemy.
    ((("pytest", "session argument")))

////
[SG] Я настроил conftest на сеанс и мог заставить тесты работать только в том случае, если я сбросил (frozen=True) на dataclass OrderLine, иначе я получил бы dataclasses.FrozenInstanceError: не могу назначить поле '_sa_instance_state', я чувствую, что мне приходится довольно много работать, чтобы следовать за ним ;-(.

Не является ли изложение всего намеренной тактикой, чтобы заставить читателя учиться?
////

Вероятно, вам не стоит хранить эти тесты. Как вы вскоре увидите, после того, как поближе познакомитесь с инверсией зависимости ORM и модели предметной области, это всего лишь небольшой дополнительный шаг для реализации другой абстракции, называемой шаблоном репозитория, для которого будет легче писать тесты, и он предоставит простой интерфейс для, скажем так -- фейка, позже в тестах.

Но мы уже достигли нашей цели инвертировать традиционную зависимость: модель предметной области остается «чистой» и свободной от инфраструктурных проблем. Мы могли бы выбросить SQLAlchemy и использовать другую ORM или совершенно другую систему сохранения, и модель предметной области вообще не нуждалась бы в изменении.


В зависимости от того, что вы делаете в своей модели предметной области, и особенно если вы отходите далеко от парадигмы объектно-ориентированного программирования, вам может оказаться все труднее заставить ORM обеспечить точное поведение, которое вам нужно, и вам может потребоваться изменить модель предметной области. footnote:[Привет чрезвычайно полезным специалистам по сопровождению SQLAlchemy и, в частности, Майку Байеру.] Как это часто бывает с архитектурными решениями, вам нужно будет найти компромисс. Как говорит дзэн Python: «Практичность лучше чистоты!»

((("SQLAlchemy", "using directly in API endpoint")))
На данный момент, однако, наш endpoint API может выглядеть примерно так, и мы могли бы заставить её работать просто отлично:

[[api_endpoint_with_session]]
.Использование SQLAlchemy непосредственно в нашем endpoint API
====
[role="skip"]
[source,python]
----
@flask.route.gubbins
def allocate_endpoint():
    session = start_session()

    # извлечение строки заказа из запроса
    line = OrderLine(
        request.json['orderid'],
        request.json['sku'],
        request.json['qty'],
    )

    # загрузите все пакеты из БД
    batches = session.query(Batch).all()

    # call our domain service
    allocate(line, batches)

    # сохраните распределения обратно в базу данных
    session.commit()

    return 201
----
====

////
[SG] из того, что я помню из предыдущего кода, если ни один из пакетов не can_allocate, тогда этот allocate(line, batches) вызовет OutOfStock.  Это нормально позволить этому пузырю подняться?  Если вы добавите попытку, наконец, закрыть сеанс
////

=== Знакомство с шаблоном репозитория

((("Repository pattern", id="ix_Repo")))
((("domain model", startref="ix_domod")))
Шаблон _Repository_ -- это абстракция над постоянным хранилищем. Он скрывает скучные детали доступа к данным, делая вид, что все наши данные находятся в памяти.

Если бы у нас была бесконечная память в наших ноутбуках, у нас не было бы необходимости в неуклюжих базах данных. Вместо этого мы могли просто использовать наши объекты, когда нам заблагорассудится. Как это будет выглядеть?

[[all_my_data]]
.Вы должны откуда-то брать данные
====
[role="skip"]
[source,python]
----
import all_my_data

def create_a_batch():
    batch = Batch(...)
    all_my_data.batches.add(batch)

def modify_a_batch(batch_id, new_quantity):
    batch = all_my_data.batches.get(batch_id)
    batch.change_initial_quantity(new_quantity)

----
====


Несмотря на то, что наши объекты находятся в памяти, нам нужно поместить их где-нибудь, чтобы снова найти их. Наши данные в памяти позволят нам добавлять новые объекты, как список или множество. Поскольку объекты находятся в памяти, нам никогда не нужно вызывать метод `.save ()`; мы просто получаем объект, который нам нужен, и модифицируем его в памяти.


==== The Repository in the Abstract

((("Repository pattern", "simplest possible repository")))
((("Unit of Work pattern")))
В простейшем репозитории всего два метода: add () для добавления нового элемента в репозиторий и get() для возврата ранее добавленного элемента.footnote:[ Вы можете подумать: «А как насчет `list`, `delete` или `update`?" Однако в идеальном мире мы модифицируем объекты нашей модели по одному, а удаление обычно обрабатывается как мягкое удаление, то есть `batch.cancel ()`. Наконец, об обновлении позаботится шаблон Unit of Work, как вы увидите в <<chapter_06_uow>>.] 

Мы твердо придерживаемся использования этих методов для доступа к данным в нашем домене и на уровне сервиса. Эта добровольная простота не позволяет нам связать нашу модель предметной области с базой данных.

((("abstract base classes (ABCs)", "ABC for the repository")))
Вот как будет выглядеть абстрактный базовый класс (ABC) для нашего репозитория:

[[abstract_repo]]
.Самый простой из возможных репозиториев (repository.py)
====
[source,python]
----
class AbstractRepository(abc.ABC):

    @abc.abstractmethod  #<1>
    def add(self, batch: model.Batch):
        raise NotImplementedError  #<2>

    @abc.abstractmethod
    def get(self, reference) -> model.Batch:
        raise NotImplementedError
----
====


<1> Python tip: `@abc.abstractmethod` -- это одна из немногих вещей, которая заставляет ABCs действительно "работать" в Python. Python не позволит вам создать экземпляр класса, который не реализует все "абстрактные методы", определенные в его родительском классе.footnote:[Чтобы действительно воспользоваться преимуществами ABC (какими бы они ни были), запустите помощники, такие как `pylint` и `mypy`.]
    ((("@abc.abstractmethod")))
    ((("abstract methods")))

<2> `raise NotImplementedError` -- это хорошо, но это не обязательно и не достаточно. На самом деле, ваши абстрактные методы могут иметь реальное поведение, которое подклассы могут вызвать, если вы действительно хотите.

[role="pagebreak-before less_space"]
.Абстрактные базовые классы, утиная типизация и протоколы
*******************************************************************************

((("abstract base classes (ABCs)", "using duck typing and protocols instead of")))
((("protocols, abstract base classes, duck typing, and")))
Мы используем абстрактные базовые классы в этой книге по дидактическим соображениям: мы надеемся, что они помогут объяснить, что такое интерфейс абстракции репозитория.

((("duck typing")))
В реальной жизни мы иногда обнаруживаем, что удаляем ABC из нашего продакшен кода, потому что Python слишком упрощает их игнорирование, и они в конечном итоге не обслуживаются и, в худшем случае, вводят в заблуждение. На практике мы часто просто полагаемся на утиную типизацию Python для включения абстракций. Для Pythonista репозиторий -- это _любой_ объект, имеющий pass:[<code>add(<em>thing</em>)</code>] and pass:[<code>get(<em>id</em>)</code>] methods.

((("PEP 544 protocols")))
Альтернативой для изучения является https://oreil.ly/q9EPC[PEP 544 protocols]. Это дает вам возможность писать классы без возможного использования наследования, что особенно понравится фанатам "предпочитать композицию наследованию".

*******************************************************************************


==== Что такое компромисс?


[quote, Рич Хикки]
____
Знаете, говорят, что экономисты знают всё о цене и ничего о ценности? Программисты же, знают всё о преимуществе и ничего о компромисе.
____

((("Repository pattern", "trade-offs")))
Всякий раз, когда мы представляем архитектурный паттерн в этой книге, мы всегда задаёмся вопроосом: «Что нам ЭТО даст? И во что нам ЭТО обойдётся?»

Обычно, вводя дополнительный уровень абстракции, мы по крайней мере надеемся, что это уменьшит сложность в целом, а в действительности всё это добавляет сложности локальной и имеет свою стоимость с точки зрения необработанного количества перемещений и текущего обслуживания.


Шаблон репозитория, вероятно, является одним из самых простых вариантов в книге, если вы уже идёте по пути DDD и инверсии зависимостей.  Что касается нашего кода, на самом деле мы просто меняем абстракцию SQLAlchemy (`session.query (Batch)`) на другую (`batches_repo.get`), которую мы разработали.

Нам придется добавлять несколько строк кода в нашем классе репозитория каждый раз, когда мы добавляем новый объект домена, который мы хотим получить, но взамен мы получаем простую абстракцию над нашим уровнем хранения, который мы контролируем. Шаблон репозитория позволит легко вносить фундаментальные изменения в то, как мы храним объекты (см. <<appendix_csvs>>), и, как мы увидим, его легко подменить для модульных тестов.

((("domain driven design (DDD)", "Repository pattern and")))
Кроме того, шаблон репозитория настолько распространен в мире DDD, что, если вы сотрудничаете с программистами, пришедшими в Python из мира Java и C#, они, скорее всего, узнают его. <<repository_pattern_diagram>> иллюстрирует этот паттерн.

[role="width-60"]
[[repository_pattern_diagram]]
.Repository pattern
image::images/apwp_0205.png[]
[role="image-source"]
----
[ditaa, apwp_0205]
  +-----------------------------+
  |      Application Layer      |
  +-----------------------------+
                 |^
                 ||          /------------------\
                 ||----------|   Domain Model   |
                 ||          |      Objects     |
                 ||          \------------------/
                 V|
  +------------------------------+
  |          Repository          |
  +------------------------------+
                 |
                 V
  +------------------------------+
  |        Database Layer        |
  +------------------------------+
----


((("Repository pattern", "testing the  repository with saving an object")))
((("SQL", "repository test for saving an object")))
Как всегда, мы начинаем с теста. Это, вероятно, было бы классифицировано как интеграционный тест, поскольку мы проверяем, что наш код (репозиторий) правильно интегрирован с базой данных; следовательно, тесты, как правило, смешивают необработанный SQL с вызовами и ассертами в нашем собственном коде.

TIP: В отличие от предыдущих тестов ORM, эти тесты являются хорошими кандидатами на то, чтобы оставаться частью вашей кодовой базы в долгосрочной перспективе, особенно если какие-либо части вашей модели предметной области означают, что объектно-реляционная карта нетривиальна.


[[repo_test_save]]
.Тест репозитория для сохранения объекта (test_repository.py)
====
[source,python]
----
def test_repository_can_save_a_batch(session):
    batch = model.Batch("batch1", "RUSTY-SOAPDISH", 100, eta=None)

    repo = repository.SqlAlchemyRepository(session)
    repo.add(batch)  #<1>
    session.commit()  #<2>

    rows = list(session.execute(
        'SELECT reference, sku, _purchased_quantity, eta FROM "batches"'  #<3>
    ))
    assert rows == [("batch1", "RUSTY-SOAPDISH", 100, None)]
----
====

<1> `repo.add()` это тестируемый здесь метод.

<2> Мы храним `.commit()` вне репозитория и возлагаем ответственность на вызывающего. В этом есть свои плюсы и минусы; некоторые из причин станут яснее, когда мы доберемся до <<chapter_06_uow>>.

<3> Используем необработанный SQL, чтобы убедиться, что были сохраненыправильные данные .
 
((("SQL", "repository test for retrieving complex object")))
((("Repository pattern", "testing the repository with retrieving a complex object")))
Следующий тест включает в себя извлечение пакетов и распределений, поэтому он более сложный:


[[repo_test_retrieve]]
.Тест репозитория для извлечения сложного объекта (test_repository.py)
====
[source,python]
----
def insert_order_line(session):
    session.execute(  #<1>
        'INSERT INTO order_lines (orderid, sku, qty)'
        ' VALUES ("order1", "GENERIC-SOFA", 12)'
    )
    [[orderline_id]] = session.execute(
        'SELECT id FROM order_lines WHERE orderid=:orderid AND sku=:sku',
        dict(orderid="order1", sku="GENERIC-SOFA")
    )
    return orderline_id

def insert_batch(session, batch_id):  #<2>
    ...

def test_repository_can_retrieve_a_batch_with_allocations(session):
    orderline_id = insert_order_line(session)
    batch1_id = insert_batch(session, "batch1")
    insert_batch(session, "batch2")
    insert_allocation(session, orderline_id, batch1_id)  #<2>

    repo = repository.SqlAlchemyRepository(session)
    retrieved = repo.get("batch1")

    expected = model.Batch("batch1", "GENERIC-SOFA", 100, eta=None)
    assert retrieved == expected  # Batch.__eq__ only compares reference  #<3>
    assert retrieved.sku == expected.sku  #<4>
    assert retrieved._purchased_quantity == expected._purchased_quantity
    assert retrieved._allocations == {  #<4>
        model.OrderLine("order1", "GENERIC-SOFA", 12),
    }
----
====


<1> Проверяет сторону чтения, поэтому необработанный SQL готовит данные для чтения `repo.get()`.

<2> Избавляем вас от деталей `insert_batch` и `insert_allocation`; Зыдача в том, чтобы создать пару партий, а для интересующей нас партии выделить одну существующую строку заказа.

<3> Вот что мы здесь проверяем. Первый `assert ==` проверяет соответствие типов и совпадение ссылок (потому что, как вы помните, `Batch` -- это сущность, и для нее у нас есть собственный ++ __ eq __ ++).

<4> Поэтому мы также явно проверяем его основные атрибуты, в том числе
    `._allocations`, который представляет собой набор Python-объектов значений `OrderLine`.

((("Repository pattern", "typical repository")))
Независимо от того, насколько вы кропотливо написали тесты для каждой модели. После того, как у вас будет протестирован один класс на создание/изменение/сохранение, вы можете продолжить и протестировать другие с минимальным тестом на обратную связь или вообще ничего, если все они следуют схожему шаблону. В нашем случае конфигурация ORM, которая устанавливает набор `._allocations`, немного сложна, поэтому заслуживает особого тестирования.


Вы получите что-то вроде этого:


[[batch_repository]]
.Типичный репозиторий (repository.py)
====
[source,python]
----
class SqlAlchemyRepository(AbstractRepository):

    def __init__(self, session):
        self.session = session

    def add(self, batch):
        self.session.add(batch)

    def get(self, reference):
        return self.session.query(model.Batch).filter_by(reference=reference).one()

    def list(self):
        return self.session.query(model.Batch).all()
----
====


((("Flask framework", "API endpoint")))
((("Repository pattern", "using repository directly in API endpoint")))
((("APIs", "using repository directly in API endpoint")))
И теперь наша конечная точка Flask может выглядеть примерно так:

[[api_endpoint_with_repo]]
.Использование нашего репозитория непосредственно в нашей конечной точке API
====
[role="skip"]
[source,python]
----
@flask.route.gubbins
def allocate_endpoint():
    batches = SqlAlchemyRepository.list()
    lines = [
        OrderLine(l['orderid'], l['sku'], l['qty'])
         for l in request.params...
    ]
    allocate(lines, batches)
    session.commit()
    return 201
----
====

[role="nobreakinside less_space"]
.Упражнение для читателя
******************************************************************************

((("SQL", "ORM and Repository pattern as abstractions in front of")))
((("Repository pattern", "ORMs and")))
((("object-relational mappers (ORMs)", "Repository pattern and")))
На днях мы столкнулись с другом на конференции DDD, который сказал: "Я не использовал ORM в течение 10 лет." Шаблон репозитория и ORM действуют как абстракции перед необработанным SQL, поэтому использование одного за другим на самом деле не является необходимым.  Почему бы не попробовать реализовать наш репозиторий без использования ORM? Вы найдете код https://github.com/cosmicpython/code/tree/chapter_02_repository_exercise[на GitHub].

Мы оставили тесты репозитория, но решать, какой SQL писать, решать вам. Возможно, это будет труднее, чем вы думаете; возможно будет легче. Но хорошо то, что остальной части вашего приложения это до лампочки.

******************************************************************************


=== Создание поддельного репозитория для тестов теперь тривиально!

((("Repository pattern", "building fake repository for tests")))
((("set, fake repository as wrapper around")))
Вот одно из самых больших преимуществ шаблона репозиторий:


[[fake_repository]]
.Простой фейковый репозиторий с использованием набора (repository.py)
====
[role="skip"]
[source,python]
----
class FakeRepository(AbstractRepository):

    def __init__(self, batches):
        self._batches = set(batches)

    def add(self, batch):
        self._batches.add(batch)

    def get(self, reference):
        return next(b for b in self._batches if b.reference == reference)

    def list(self):
        return list(self._batches)
----
====

Поскольку это простая оболочка для `set`, все методы являются однострочными.

Использовать фальшивое репо в тестах действительно просто, и у нас есть простая абстракция, которую легко использовать и рассуждать:

[[fake_repository_example]]
.Пример использования поддельного репозитория (test_api.py)
====
[role="skip"]
[source,python]
----
fake_repo = FakeRepository([batch1, batch2, batch3])
----
====

Вы увидите эту подделку в действии в следующей главе.


TIP: Создание подделок для ваших абстракций - отличный способ получить обратную связь от дизайна: если подделать сложно, значит, абстракция слишком сложна.


[[what_is_a_port_and_what_is_an_adapter]]
=== Что такое порт и что такое адаптер в Python?

((("ports", "defined")))
((("adapters", "defined")))
Мы не хотим слишком подробно останавливаться здесь на терминологии, потому что главное, на чем мы хотим сосредоточиться, - это инверсия зависимостей, а специфика используемой вами техники не имеет большого значения. Кроме того, мы знаем, что разные люди используют несколько разные определения.

Порты и адаптеры вышли из мира OO, и определение, которое мы придерживаемся, состоит в том, что _port_ -- это _interface_ между нашим приложением и тем, что мы хотим абстрагировать, а _adapter_ -- это _implementation (реализация)_ за этим интерфейсом или абстракцией.

((("interfaces, Python and")))
((("duck typing", "for ports")))
((("abstract base classes (ABCs)", "using for ports")))
Python не имеет интерфейсов как таковых, поэтому, хотя обычно легко идентифицировать адаптер, определение порта может быть сложнее. Если вы используете абстрактный базовый класс, это порт. Если нет, то порт—это просто duck type, которому соответствуют ваши адаптеры и который ожидает ваше основное приложение -- имена используемых функций и методов, а также имена и типы их аргументов.

Конкретно, в этой главе, `AbstractRepository` это порт, a
`SqlAlchemyRepository` и `FakeRepository` - это адаптеры.



=== Заключение

((("Repository pattern", "and persistence ignorance, trade-offs")))
((("persistence ignorance", "trade-offs")))
Помня цитату Рича Хики, в каждой главе мы суммируем затраты и преимущества каждого представленного архитектурного шаблона.  Мы хотим, чтобы было ясно, что мы не говорим, что каждое отдельное приложение должно быть построено именно таким образом; только иногда сложность приложения и домена заставляет тратить время и усилия на добавление этих дополнительных слоев косвенности.

Имея это в виду, <<chapter_02_repository_tradeoffs>> показывает некоторые плюсы и минусы шаблона репозитория и нашей модели с игнорированием персистентности.

////
[SG] стоит ли упоминать, что репозиторий специально предназначен для добавления и получения объектов нашей доменной модели, а не для добавления и получения любых старых данных, которые вы могли бы назвать DAO. Репозиторий находится ближе к бизнес-домену.
////

[[chapter_02_repository_tradeoffs]]
[options="header"]
.Шаблон репозитория и persistence ignorance: компромиссы
|===
|Плюсы|Минусы
a|
* У нас есть простой интерфейс между persistent (постоянным) хранилищем и нашей доменной моделью.

* Легко создать фейковую версию репозитория для модульного тестирования или заменить другие решения для хранения, потому что мы полностью отделили модель от проблем инфраструктуры.

* Написание модели предметной области, прежде чем думать о персистентности, помогает нам сосредоточиться на текущей бизнес-проблеме. Если мы когда-нибудь захотим радикально изменить наш подход, мы можем сделать это в нашей модели, не беспокоясь о внешних ключах или миграциях до более позднего времени.

* Наша схема базы данных очень проста, потому что у нас есть полный контроль над тем, как мы сопоставляем наши объекты с таблицами.

a|
* ORM уже окупает вам затраты. Смена внешних ключей может создать сложности, но при необходимости будет довольно легко переключаться между MySQL и Postgres.

////
[КП] Я всегда находил это преимущество ORM довольно слабым. В тех редких случаях, когда мне действительно приходилось переключать движки БД, выигрыш был достаточно высок, чтобы оправдать некоторую дополнительную работу. Кроме того, если вы используете "интересные" функции БД (скажем, специальные поля Postgres), вы обычно теряете переносимость.
////


* Ведение сопоставлений ORM вручную требует дополнительной работы и дополнительного кода.

* Любой дополнительный уровень косвенности всегда увеличивает затраты на обслуживание и добавляет "фактор WTF" для программистов Python, которые никогда раньше не видели шаблон репозитория.
|===

<<domain_model_tradeoffs_diagram>> демонстрирует основной тезис: да, для простых случаев развязанная модель предметной области является более сложной работой, чем простой шаблон ORM/ActiveRecord.footnote:[Диаграмма вдохновлена ​​публикацией под названием
https://oreil.ly/fQXkP[ «Глобальная сложность, локальная простота»] Роба Венса.]

TIP: Если ваше приложение представляет собой простую оболочку CRUD (создание-чтение-обновление-удаление) вокруг базы данных, вам не нужна модель предметной области или репозиторий.

((("domain model", "trade-offs as a diagram")))
((("Vens, Rob")))
((("&quot;Global Complexity, Local Simplicity&quot; post", primary-sortas="Global")))
Но чем сложнее домен, тем больше окупаются инвестиции в избавление от проблем с инфраструктурой с точки зрения простоты внесения изменений.


[[domain_model_tradeoffs_diagram]]
.Компромиссы модели предметной области в виде диаграммы
image::images/apwp_0206.png[]


Наш пример кода не настолько сложен, чтобы дать больше, чем намек на то, как выглядит правая часть графика, но намеки есть. Представьте себе, например, что однажды мы решим, что хотим изменить распределение, чтобы жить на "OrderLine", а не на "Batch" объекте: если бы мы использовали, скажем, Django, нам пришлось бы определить и продумать миграцию базы данных, прежде чем мы могли бы запустить какие-либо тесты. Как бы то ни было, поскольку наша модель-это просто старые объекты Python, мы можем изменить `set()` на новый атрибут, не думая о базе данных до более подходящего момента.

[role="nobreakinside"]
.Резюме шаблона репозитория
*****************************************************************
Применение инверсии зависимости в ORM::
    Наша модель предметной области должна быть свободна от проблем с инфраструктурой, поэтому ваш ORM должен импортировать вашу модель, а не наоборот.
    ((("Repository pattern", "recap of important points")))

Шаблон репозитория -- это простая абстракция вокруг постоянного хранилища::
    Репозиторий дает вам иллюзию коллекции объектов в памяти. Это позволяет легко создать "FakeRepository" для тестирования и поменять местами основные детали вашей инфраструктуры, не нарушая работу вашего основного приложения. Смотрите
    <<appendix_csvs>> для примера.
*****************************************************************

Вам будет интересно, как мы создаем экземпляры этих хранилищ, поддельные или настоящие? Как на самом деле будет выглядеть наше приложение Flask? Вы узнаете об этом в следующей захватывающей части, <<chapter_04_service_layer,the Service Layer pattern>>.

Но сначала небольшое отступление.
((("Repository pattern", startref="ix_Repo")))
