[[part2]]
[part]
== Событийно-Ориентированная архитектура

[quote, Alan Kay]
____

Мне жаль, что я давным-давно придумал термин "объекты" для этой темы, потому что он заставляет многих людей сосредоточиться на менее значимой идее.

Главная идея-это "_messaging_ обмен сообщениями"....Ключ к созданию больших и растущих систем гораздо больше заключается в том, чтобы спроектировать, как его модули взаимодействуют, а не в том, какими должны быть их внутренние свойства и поведение.
____

Все это очень хорошо, когда мы можем написать _одну_ доменную модель для управления одним участком бизнес-процесса, но что происходит, когда нам нужно написать _несколько_ моделей? В реальном мире наши приложения находятся внутри организации и должны обмениваться информацией с другими частями системы. Возможно, вы помните нашу контекстную диаграмму, показанную в <<allocation_context_diagram_again>>.

Столкнувшись с этим требованием, многие команды обращаются к микросервисам, интегрированным через HTTP API. Но если они не будут осторожны, то в конечном итоге создадут самый хаотичный беспорядок из всех: распределенный БОЛЬШОЙ ШАР ГРЯЗИ.

В части II мы покажем, как методы из <<части 1>> могут быть распространены на распределенные системы. Мы уменьшим масштаб, чтобы посмотреть, как мы можем составить систему из множества небольших компонентов, которые взаимодействуют посредством асинхронной передачи сообщений.

Мы увидим, как наш Уровень обслуживания и шаблоны единиц работы позволяют нам перенастроить наше приложение для работы в качестве асинхронного процессора сообщений и как системы, управляемые событиями, помогают нам отделить агрегаты и приложения друг от друга.

[[allocation_context_diagram_again]]
.Но как именно все эти системы будут общаться друг с другом?
image::images/apwp_0102ru.png[]


// TODO: DS - this might give the impression that the whole of part 2
// is irrelevant for readers in a monolith context

//IDEA (DS): It seems to me the two key themes in this book are vertical and
//horizontal decoupling. Did you consider choosing those for the two parts?

Мы рассмотрим следующие шаблоны и техники:

События домена ::
  Триггерные рабочие процессы, которые пересекают границы консистенции.

Шина сообщений ::
  Обеспечивает унифицированный способ вызова случаев использования из любой конечной точки.

CQRS::
  Разделяет операций чтения и записи позволяет избежать неудобных компромиссов в событийно-управляемой архитектуре и повысить производительность и масштабируемость.

Плюс, мы добавим каркас для инъекций зависимостей. Это не имеет ничего общего с архитектурой, основанной на событиях как таковой, но она убирает очень много свободных концовок.

// IDEA: a bit of blurb about making events more central to our design thinking?
