:doctype: book
:source-highlighter: pygments
:icons: font
:toc: left
:toclevels: 2

[[chapter_08_events_and_message_bus]]
== События и шина сообщений

((("events and the message bus", id="ix_evntMB")))
Итак, мы потратили кучу времени и энергии на простую проблему, которую мы могли бы легко решить с помощью Django. Возможно, вы задаётесь вопросом, _действительно_ ли повышенная тестируемость и выразительность стоят всех усилий?!

Однако на практике мы обнаруживаем, что не очевидные функции создают беспорядок в наших кодовых базах: это нечто липкое и тупое скопившееся по краю. Это отчеты, разрешения и рабочие процессы, которые затрагивают миллион объектов.

Нашим примером будет типичное требование к уведомлению: когда мы не можем разместить заказ, потому что его нет в наличии, мы должны предупредить отдел сбыта. Они пойдут и решат проблему, закупив побольше запасов, и все будет хорошо.

В случае первой версии, наш владелец только должен отправить предупреждение по электронной почте.

Давайте посмотрим, как выдержит наша архитектура, когда нам нужно подключить некоторые прозаичные вещи, которые составляют так много наших систем.

Мы начнём с самого простого, самого быстрого решения и дальше поговорим о том, почему именно такое решение приводит нас к Большому Комку грязи.

((("Message Bus pattern")))
((("Domain Events pattern")))
((("events and the message bus", "events flowing through the system")))
((("Unit of Work pattern", "modifying to connect domain events and message bus")))
Затем мы покажем, как использовать шаблон _Domain Events_ для отделения побочных эффектов от наших вариантов использования, и как использовать простой шаблон _Message Bus_ для запуска поведения на основе этих событий. Мы покажем несколько вариантов для создания этих событий и того, как передать их в шину сообщений, и, наконец, мы покажем, как можно изменить шаблон Unit of Work, чтобы элегантно соединить их вместе, как показано в <<message_bus_diagram> >.

[[message_bus_diagram]]
.События, протекающие через систему
image::images/apwp_0801.png[]

// TODO: add before diagram for contrast (?)


[TIP]
====
Код этой главы находится в ветке chapter_08_events_and_message_bus https://oreil.ly/M-JuL[на GitHub]:

----
git clone https://github.com/cosmicpython/code.git
cd code
git checkout chapter_08_events_and_message_bus
# или, чтобы дальше кодировать вместе, проверьте предыдущую главу:
git checkout chapter_07_aggregate
----
====


=== Как избежать беспорядка

((("web controllers, sending email alerts via, avoiding")))
((("events and the message bus", "sending email alerts when out of stock", id="ix_evntMBeml")))
((("email alerts, sending when out of stock", id="ix_email")))
Так. Уведомления по электронной почте, когда у нас заканчивается товар. Когда у нас появляются новые требования, вроде тех, которые _в действительности_ не имеют ничего общего с основным доменом, очень легко начать сбрасывать эти вещи в наши веб-контроллеры.


==== Во-первых, давайте не будем путать наши веб-контроллеры

((("events and the message bus", "sending email alerts when out of stock", "avoiding messing up web controllers")))
В качестве одноразового взлома, это _может_ быть допустимо:

[[email_in_flask]]
.Просто сунь его в endpoint—что может пойти не так? (src/allocation/entrypoints/flask_app.py)
====
[source,python]
[role="skip"]
----
@app.route("/allocate", methods=['POST'])
def allocate_endpoint():
    line = model.OrderLine(
        request.json['orderid'],
        request.json['sku'],
        request.json['qty'],
    )
    try:
        uow = unit_of_work.SqlAlchemyUnitOfWork()
        batchref = services.allocate(line, uow)
    except (model.OutOfStock, services.InvalidSku) as e:
        send_mail(
            'out of stock',
            'stock_admin@made.com',
            f'{line.orderid} - {line.sku}'
        )
        return jsonify({'message': str(e)}), 400

    return jsonify({'batchref': batchref}), 201
----
====

...но легко понять, как мы можем быстро попасть в переделку, если так всё сделать. Отправка электронной почты не является задачей нашего HTTP-уровня, и мы хотели бы иметь возможность протестировать эту новую функцию.


==== И давайте не будем портить нашу модель

((("domain model", "email sending code in, avoiding")))
((("events and the message bus", "sending email alerts when out of stock", "avoiding messing up domain model")))
Предполагая, что мы не хотим помещать этот код в наши веб-контроллеры, потому что мы хотим, чтобы они были как можно более тонкими, мы можем посмотреть на то, чтобы поместить его прямо в источник, в модель:

[[email_in_model]]
.Код отправки электронной почты в нашей модели тоже не очень хорош (src/allocation/domain/model.py)
====
[source,python]
[role="non-head"]
----
    def allocate(self, line: OrderLine) -> str:
        try:
            batch = next(
                b for b in sorted(self.batches) if b.can_allocate(line)
            )
            #...
        except StopIteration:
            email.send_mail('stock@made.com', f'Out of stock for {line.sku}')
            raise OutOfStock(f'Out of stock for sku {line.sku}')
----
====

Но это еще хуже! Мы не хотим, чтобы наша модель имела какие-либо зависимости от инфраструктурных проблем, таких как `email.send_mail`.

Эта штука с отправкой электронной почты нежелательна _сгусток_, испортивший приятный чистый поток нашей системы. Мы хотели бы, чтобы наша модель предметной области была ориентирована на правило "Вы не можете выделить больше материала, чем на самом деле доступно."


==== Или уровень обслуживания!

((("service layer", "sending email alerts when out of stock, avoiding")))
((("events and the message bus", "sending email alerts when out of stock", "out of place in the service layer")))
Требование "Попробуйте распределить некоторый запас и отправить электронное письмо, если это не удастся" является примером оркестровки рабочего процесса: это набор шагов, которые система должна выполнить, чтобы [.keep-together]#достичь# цели.

Мы написали сервисный уровень для управления оркестровкой для нас, но даже здесь эта функция кажется неуместной:

[[email_in_services]]
.И на сервисном уровне, это неуместно (src/allocation/service_layer/services.py)
====
[source,python]
[role="non-head"]
----
def allocate(
        orderid: str, sku: str, qty: int,
        uow: unit_of_work.AbstractUnitOfWork
) -> str:
    line = OrderLine(orderid, sku, qty)
    with uow:
        product = uow.products.get(sku=line.sku)
        if product is None:
            raise InvalidSku(f'Invalid sku {line.sku}')
        try:
            batchref = product.allocate(line)
            uow.commit()
            return batchref
        except model.OutOfStock:
            email.send_mail('stock@made.com', f'Out of stock for {line.sku}')
            raise
----
====

((("email alerts, sending when out of stock", startref="ix_email")))
((("events and the message bus", "sending email alerts when out of stock", startref="ix_evntMBeml")))
Поймать исключение и сделать ререйз? Могло быть и хуже, но это определенно нас огорчает. Почему так сложно найти подходящий дом для этого кода?

=== Single Responsibility Principle

((("single responsibility principle (SRP)")))
((("events and the message bus", "sending email alerts when out of stock", "violating the single responsibility principle")))
На самом деле, это нарушение __принципа единственной ответственности__ (SRP) .footnote: [Этот принцип -- _S_ в https://oreil.ly/AIdSD[SOLID].] Наш пример использования -- распределение. Наша конечная точка, служебная функция и методы домена называются [.keep-together] #`allocate`#, а не `allocate_and_send_mail_if_out_of_stock`.

TIP: Эмпирическое правило: если вы не можете описать, что делает ваша функция, не используя такие слова, как "тогда" или "и", вы можете нарушить SRP.

Согласно одной из формулировок SRP, у каждого класса должна быть только одна причина для изменения. Когда мы переключаемся с электронной почты на SMS, нам не нужно обновлять нашу функцию `allocate()`, потому что это явно отдельная ответственность.

((("choreography")))
((("orchestration", "changing to choreography")))
Чтобы решить эту проблему, мы разделим оркестровку на отдельные этапы, чтобы различные проблемы не перепутались.footnote:[ Наш технический обозреватель Эд Юнг любит говорить, что когда вы переходите от императивного управления потоком к управлению потоком на основе событий, вы меняете _orchestration_ на _choreography_.] Задача модели домена состоит в том, чтобы знать, что у нас нет запасов, но ответственность за отправку предупреждения лежит на другом месте. Мы должны иметь возможность включать или выключать эту функцию или переключаться на SMS-уведомления вместо этого, не меняя правила нашей доменной модели.

Мы также хотели бы сохранить уровень сервиса свободным от деталей реализации. Мы хотим применить принцип инверсии зависимостей к уведомлениям, чтобы наш уровень обслуживания зависел от абстракции, точно так же, как мы избегаем зависимости от базы данных, используя единицу работы.


=== Все на борт автобуса Сообщений!

Шаблоны, которые мы собираемся здесь представить, - это _Domain Events_ События домена и _Message Bus_ Шина сообщений. Мы можем реализовать их несколькими способами, поэтому мы покажем пару, прежде чем остановимся на том, который нам больше всего нравится.

// TODO: at this point the message bus is really just a dispatcher.  could also mention
// pubsub.  once we get a queue, it's more justifiably a bus


==== Модель Записывает События

((("events and the message bus", "recording events")))
Во-первых, вместо того, чтобы беспокоиться об электронных письмах, наша модель будет отвечать за регистрацию _events_ (событий) - факты о том, что произошло. Мы будем использовать шину сообщений, чтобы отвечать на события и вызывать новую операцию.


==== События (events) - это простые классы данных

((("dataclasses", "events")))
((("events and the message bus", "events as simple dataclasses")))
_event_-это своего рода _value object_. События не имеют никакого поведения, потому что они являются чистыми структурами данных. Мы всегда называем события на языке домена и думаем о них как о части нашей модели домена.

Мы могли бы хранить их в _model.py_, но мы также можем хранить их в отдельном файле.
 (возможно, сейчас самое подходящее время подумать о рефакторинге каталога с именем _domain_, чтобы у нас был _domain/model.py_ и _domain/events.py_):

[role="nobreakinside less_space"]
[[events_dot_py]]
.Классы событий (src/allocation/domain/events.py)
====
[source,python]
----
from dataclasses import dataclass

class Event:  #<1>
    pass

@dataclass
class OutOfStock(Event):  #<2>
    sku: str
----
====


<1> Как только у нас будет несколько событий, нам будет полезно иметь родительский класс, который может хранить общие атрибуты. Это также полезно для подсказок типа в нашей шине сообщений, как вы вскоре увидите.

<2> `dataclasses` отлично подходят и для доменных событий.



==== Модель вызывает события

((("events and the message bus", "domain model raising events")))
((("domain model", "raising events")))
Когда наша модель домена фиксирует факт, который произошел, мы говорим, что это _raises (поднимает)_ событие.

((("aggregates", "testing Product object to raise events")))
Вот как это будет выглядеть со стороны; если мы попросим "Product" распределить  ( _allocate_ ), но он не сможет, он должен _raise (поднять)_ событие:


[[test_raising_event]]
.Протестируйте наш агрегат, чтобы поднять события (tests/unit/test_product.py)
====
[source,python]
----
def test_records_out_of_stock_event_if_cannot_allocate():
    batch = Batch('batch1', 'SMALL-FORK', 10, eta=today)
    product = Product(sku="SMALL-FORK", batches=[batch])
    product.allocate(OrderLine('order1', 'SMALL-FORK', 10))

    allocation = product.allocate(OrderLine('order2', 'SMALL-FORK', 1))
    assert product.events[-1] == events.OutOfStock(sku="SMALL-FORK")  #<1>
    assert allocation is None
----
====

<1> Наш агрегат предоставит новый атрибут под названием `.events`, который будет содержать список фактов о том, что произошло, в форме объектов `Event`.

Вот как выглядит модель изнутри:


[[domain_event]]
.Модель вызывает событие предметной области (src/allocation/domain/model.py)
====
[source,python]
[role="non-head"]
----
class Product:

    def __init__(self, sku: str, batches: List[Batch], version_number: int = 0):
        self.sku = sku
        self.batches = batches
        self.version_number = version_number
        self.events = []  # type: List[events.Event]  #<1>

    def allocate(self, line: OrderLine) -> str:
        try:
            #...
        except StopIteration:
            self.events.append(events.OutOfStock(line.sku))  #<2>
            # raise OutOfStock(f'Out of stock for sku {line.sku}')  #<3>
            return None
----
====

<1> Вот наш новый атрибут `.events`.

<2> Вместо того, чтобы напрямую вызывать какой-либо код отправки электронной почты, мы записываем эти события в том месте, где они происходят, используя только язык домена.

<3> Мы также собираемся прекратить создавать исключение для случая отсутствия на складе. Событие выполнит ту работу, которую выполняло исключение.



NOTE: На самом деле мы "принюхиваемся" к коду, который мы рассматривали до сих пор, а именно к тому, что обсуждается в https://oreil.ly/IQB51[использование исключений для потока управления]. В общем случае, если вы реализуете доменные события, не создавайте исключений для описания одной и той же концепции домена.     Как вы увидите позже, когда мы будем обрабатывать события в шаблоне Unit of Work, это сбивает с толку, когда приходится рассуждать о совместном использовании событий и исключений.
    ((("control flow, using exceptions for")))
    ((("exceptions", "using for control flow")))



==== Шина сообщений сопоставляет События(Events) с Обработчиками(Handlers)

((("message bus", "mapping events to handlers")))
((("events and the message bus", "message bus mapping events to handlers")))
((("publish-subscribe system", "message bus as", "handlers subscribed to receive events")))
Шина сообщений в основном говорит: "Когда я вижу это событие, я должен вызвать следующую функцию обработчика". Другими словами, это простая система подписки на публикации. Обработчики _подписаны (subscribed)_ на получение событий, которые мы размещаем в шине. Это звучит сложнее, чем есть на самом деле, и мы обычно реализуем это с помощью dict:

[[messagebus]]
.Simple message bus (src/allocation/service_layer/messagebus.py)
====
[source,python]
----
def handle(event: events.Event):
    for handler in HANDLERS[type(event)]:
        handler(event)


def send_out_of_stock_notification(event: events.OutOfStock):
    email.send_mail(
        'stock@made.com',
        f'Out of stock for {event.sku}',
    )


HANDLERS = {
    events.OutOfStock: [send_out_of_stock_notification],

}  # type: Dict[Type[events.Event], List[Callable]]
----
====

NOTE: Обратите внимание, что реализованная шина сообщений не дает нам параллелизма, потому что одновременно будет работать только один обработчик. Наша цель состоит не в том, чтобы поддерживать параллельные потоки, а в том, чтобы концептуально разделить задачи и сделать каждый UoW как можно меньше. Это помогает нам понять кодовую базу, потому что "рецепт" для запуска каждого варианта использования написан в одном месте. См. следующую боковую панель.
    ((("concurrency", "not provided by message bus implementation")))

[role="nobreakinside less_space"]
[[celery_sidebar]]
.Это как Celery?
*******************************************************************************
((("message bus", "Celery and")))
_Celery_ -- это популярный в мире Python инструмент для переноса автономных фрагментов работы в асинхронную очередь задач.((("Celery tool"))) Шина сообщений, которую мы представляем здесь, очень отличается, поэтому короткий ответ на вышеприведенный вопрос-нет; наша шина сообщений имеет больше общего с Express.js приложение, цикл событий пользовательского интерфейса или структура актера.
// TODO: this "more in common with" line is not super-helpful atm.  maybe onclick callbacks in js would be a more helpful example

((("external events")))
Если у вас есть необходимость перенести работу из основного потока, вы все еще можете использовать наши event-based metaphors (метафоры, основанные на событиях), но мы предлагаем вам использовать для этого _external events_. Это более подробно обсуждается в <<chapter_11_external_events_tradeoffs>>, но по сути, если вы реализуете способ сохранения событий в централизованном хранилище, вы можете подписаться на другие контейнеры или другие микросервисы. Затем та же самая концепция использования событий для разделения обязанностей между единицами работы в рамках одного process/service может быть распространена на несколько процессов, которые могут быть различными контейнерами в рамках одной и той же службы или совершенно разными микросервисами.

Если вы следуете нашему подходу, ваш API для распределения задач-это ваше событие [.keep-together]##классы—##или их JSON-представление. Это дает вам большую гибкость в том, кому вы распределяете задачи; они не обязательно должны быть службами Python. Celery's API для распределения задач -- это, по сути, "имя функции плюс аргументы", что является более ограничительным и только для Python.

*******************************************************************************


=== Вариант 1. Уровень сервиса Принимает События из Модели и Помещает их в Шину сообщений

((("domain model", "events from, passing to message bus in service layer")))
((("message bus", "service layer with explicit message bus")))
((("service layer", "taking events from model and putting them on message bus")))
((("events and the message bus", "service layer with explicit message bus")))
((("publish-subscribe system", "message bus as", "publishing step")))
Наша доменная модель вызывает события, и наша шина сообщений будет вызывать правые обработчики всякий раз, когда происходит событие. Теперь все, что нам нужно, -- это соединить их. Нам нужно что-то, чтобы перехватить события из модели и передать их в шину сообщений -- этап _publishing_.

Самый простой способ сделать это -- добавить код в наш сервисный слой:

[[service_talks_to_messagebus]]
.Уровень обслуживания с явной шиной сообщений (src/allocation/service_layer/services.py)
====
[source,python]
[role="non-head"]
----
from . import messagebus
...

def allocate(
        orderid: str, sku: str, qty: int,
        uow: unit_of_work.AbstractUnitOfWork
) -> str:
    line = OrderLine(orderid, sku, qty)
    with uow:
        product = uow.products.get(sku=line.sku)
        if product is None:
            raise InvalidSku(f'Invalid sku {line.sku}')
        try:  #<1>
            batchref = product.allocate(line)
            uow.commit()
            return batchref
        finally:  #<1>
            messagebus.handle(product.events)  #<2>
----
====

<1> Мы сохраняем `try/finally` из нашей уродливой более ранней реализации (мы еще не избавились от _всех_ исключений, просто `OutOfStock`).

<2> Но теперь, вместо того чтобы напрямую зависеть от инфраструктуры электронной почты, уровень сервиса отвечает только за передачу событий от модели до шины сообщений.

Это уже позволяет избежать некоторого уродства, которое мы имели в нашей наивной реализации, и у нас есть несколько систем, работающих подобно этой, в которых уровень обслуживания явно собирает события из агрегатов и передает их в шину сообщений.


=== Вариант 2: Уровень Сервиса Создает Свои Собственные События

((("service layer", "raising its own events")))
((("events and the message bus", "service layer raising its own events")))
((("message bus", "service layer raising events and calling messagebus.handle")))
Другой вариант, который мы использовали, - это сделать так, чтобы уровень сервиса отвечал за создание и инициирование событий напрямую, а не за их создание моделью предметной области:


[[service_layer_raises_events]]
.Service layer calls messagebus.handle directly (src/allocation/service_layer/services.py)
====
[source,python]
[role="skip"]
----
def allocate(
        orderid: str, sku: str, qty: int,
        uow: unit_of_work.AbstractUnitOfWork
) -> str:
    line = OrderLine(orderid, sku, qty)
    with uow:
        product = uow.products.get(sku=line.sku)
        if product is None:
            raise InvalidSku(f'Invalid sku {line.sku}')
        batchref = product.allocate(line)
        uow.commit() #<1>

        if batchref is None:
            messagebus.handle(events.OutOfStock(line.sku))
        return batchref
----
====

<1> Как и раньше, мы коммитим событие, даже если ничего не можем зарезервировать, потому что код таким образом проще и легче понимать: мы всегда фиксируем, если что-то не идет не так. Фиксация, когда мы ничего не изменили, безопасна и сохраняет код незагроможденным.

Опять же, у нас есть приложения в производстве (production), которые реализуют шаблон таким образом.  То, что работает для вас, будет зависеть от конкретных компромиссов, с которыми вы столкнётесь, но мы хотели бы показать вам, что мы считаем наиболее элегантным решением, в котором мы помещаем единицу работы, отвечающую за сбор и обработку событий.

=== Вариант 3: UoW публикует события в шине сообщений

((("message bus", "Unit of Work publishing events to")))
((("events and the message bus", "UoW publishes events to message bus")))
((("Unit of Work pattern", "UoW publishing events to message bus")))
У UoW уже есть блок `try/finally`, и он знает обо всех агрегатах, находящихся в данный момент в игре, потому что он предоставляет доступ к репозиторию. Так что это хорошее место для обнаружения событий и передачи их в шину сообщений:


[[uow_with_messagebus]]
.UoW обеспечивает шину сообщений (src/allocation/service_layer/unit_of_work.py)
====
[source,python]
----
class AbstractUnitOfWork(abc.ABC):
    ...

    def commit(self):
        self._commit()  #<1>
        self.publish_events()  #<2>

    def publish_events(self):  #<2>
        for product in self.products.seen:  #<3>
            while product.events:
                event = product.events.pop(0)
                messagebus.handle(event)

    @abc.abstractmethod
    def _commit(self):
        raise NotImplementedError

...

class SqlAlchemyUnitOfWork(AbstractUnitOfWork):
    ...

    def _commit(self):  #<1>
        self.session.commit()
----
====

<1> Мы изменим наш метод фиксации, чтобы запросить частный метод `._commit()` из подклассов.

<2> После фиксации мы прогоняем все объекты, которые воспринял наш репозиторий, и передаем их события в шину сообщений.

<3> Это зависит от репозитория, отслеживающего агрегаты, которые были загружены с использованием нового атрибута, `.seen`, как вы увидите в следующем листинге.
    ((("repositories", "repository keeping track of aggregates passing through it")))
    ((("aggregates", "repository keeping track of aggregates passing through it")))

NOTE: Вам интересно, что произойдет, если один из обработчиков выйдет из строя? Мы подробно обсудим обработку ошибок в <<chapter_10_commands>>.


//IDEA: could change ._commit() to requiring super().commit()


[[repository_tracks_seen]]
.Репозиторий отслеживает агрегаты, которые проходят через него (src/allocation/adapters/repository.py)
====
[source,python]
----
class AbstractRepository(abc.ABC):

    def __init__(self):
        self.seen = set()  # type: Set[model.Product]  #<1>

    def add(self, product: model.Product):  #<2>
        self._add(product)
        self.seen.add(product)

    def get(self, sku) -> model.Product:  #<3>
        product = self._get(sku)
        if product:
            self.seen.add(product)
        return product

    @abc.abstractmethod
    def _add(self, product: model.Product):  #<2>
        raise NotImplementedError

    @abc.abstractmethod  #<3>
    def _get(self, sku) -> model.Product:
        raise NotImplementedError



class SqlAlchemyRepository(AbstractRepository):

    def __init__(self, session):
        super().__init__()
        self.session = session

    def _add(self, product):  #<2>
        self.session.add(product)

    def _get(self, sku):  #<3>
        return self.session.query(model.Product).filter_by(sku=sku).first()
----
====

<1> Чтобы UoW мог публиковать новые события, он должен иметь возможность запрашивать репозиторий, для каких объектов `Product` использовались во время этого сеанса. Мы используем `set` под названием` .seen` для их хранения. Это означает, что наши реализации должны вызывать +++ <code> super().__ init __() </code> +++.
    ((("super function")))

<2> Родительский метод `add()` добавляет элементы в `.seen` и теперь требует jn подклассов реализацию `._add()`.

<3> Аналогично, `.get()` делегирует функцию `._get ()`, которая должна быть реализована подклассами, чтобы захватить видимые объекты.


NOTE: Использование методов pass:[<code><em>._underscorey()</em></code>] и подклассов определенно не является единственным способом реализации этих шаблонов. Попробуйте воспользоваться <<get_rid_of_commit,"Упражнения для читателя">> в этой главе и поэкспериментируйте с некоторыми альтернативами.

После того, как UoW и репозиторий будут сотрудничать таким образом, чтобы автоматически отслеживать живые объекты и обрабатывать их события, уровень сервиса может быть полностью свободен от проблем с обработкой событий:
((("service layer", "totally free of event handling concerns")))

[[services_clean]]
.Сервисный слой снова чист (src/allocation/service_layer/services.py)
====
[source,python]
----
def allocate(
        orderid: str, sku: str, qty: int,
        uow: unit_of_work.AbstractUnitOfWork
) -> str:
    line = OrderLine(orderid, sku, qty)
    with uow:
        product = uow.products.get(sku=line.sku)
        if product is None:
            raise InvalidSku(f'Invalid sku {line.sku}')
        batchref = product.allocate(line)
        uow.commit()
        return batchref
----
====

((("super function", "tweaking fakes in service layer to call")))
((("service layer", "tweaking fakes in to call super and implement underscorey methods")))
((("faking", "tweaking fakes in service layer to call super and implement underscorey methods")))
((("underscorey methods", "tweaking fakes in service layer to implement")))
Мы также должны помнить, что надо изменить фейки в сервисном слое и заставить их вызывать `super()` в нужных местах, а также реализовать методы c двойным подчёркиванием ("__str__","__repr__"), но изменения минимальны:


[[services_tests_ugly_fake_messagebus]]
.Фейки сервисного уровня нуждаются в настройке (tests/unit/test_services.py)
====
[source,python]
----
class FakeRepository(repository.AbstractRepository):

    def __init__(self, products):
        super().__init__()
        self._products = set(products)

    def _add(self, product):
        self._products.add(product)

    def _get(self, sku):
        return next((p for p in self._products if p.sku == sku), None)

...

class FakeUnitOfWork(unit_of_work.AbstractUnitOfWork):
    ...

    def _commit(self):
        self.committed = True

----
====

[role="nobreakinside less_space"]
[[get_rid_of_commit]]
.Упражнения для читателя
******************************************************************************

((("inheritance, avoiding use of with wrapper class")))
((("underscorey methods", "avoiding by implementing TrackingRepository wrapper class")))
((("composition over inheritance in TrackingRepository wrapper class")))
((("repositories", "TrackerRepository wrapper class")))
Вы находите все эти методы `._add ()` и `._commit()` "супер-навороченными", по словам нашего любимого технического обозревателя Хайнека? Это "возбудит у вас желание шмякнуть Гарри по голове плюшевой змеей"? Эй, наши куски кода предназначены только для примеров, а не для идеального решения! Почему бы не пойти и не глянуть, сможешь ли ты сделать лучше?

Одним из способов _пеподнять композицию над наследованием_ было бы реализовать класс-декоратор:

[[tracking_repo_wrapper]]
.Обертка добавляет функциональность, а затем делегирует (src/adapters/repository.py)
====
[source,python]
[role="skip"]
----
class TrackingRepository:
    seen: Set[model.Product]

    def __init__(self, repo: AbstractRepository):
        self.seen = set()  # type: Set[model.Product]
        self._repo = repo

    def add(self, product: model.Product):  #<1>
        self._repo.add(product)  #<1>
        self.seen.add(product)

    def get(self, sku) -> model.Product:
        product = self._repo.get(sku)
        if product:
            self.seen.add(product)
        return product
----
====

<1> Обернув репозиторий, мы можем вызывать фактические методы `.add ()` и `.get ()`, избегая волшебных методов с двойным подчёркиванием.

((("Unit of Work pattern", "getting rid of underscorey methods in UoW class")))
Посмотрите, можете ли вы применить аналогичный шаблон к нашему классу UoW, чтобы избавиться и от тех Java-подобных методов `_commit()`. Вы можете найти код наhttps://github.com/cosmicpython/code/tree/chapter_08_events_and_message_bus_exercise[GitHub].

((("abstract base classes (ABCs)", "switching to typing.Protocol")))
Переключение всех ABC на `typing.Protocol` - хороший способ заставить себя
избегайте использования наследования. Дайте нам знать, если у вас получится что-нибудь приятное!
******************************************************************************

Возможно, вы начинаете беспокоиться о том, что поддержание этих фейков будет бременем для обслуживания. Нет никаких сомнений, что это работа, но по нашему опыту это не так уж много работы. Как только ваш проект  запущен и работает, интерфейс для вашего репозитория и абстракций UoW действительно не сильно меняется. И если вы используете ABC, это поможет вам вспомнить, когда что-то выходит из синхронизации.

=== Подведение итогов

События домена дают нам возможность управлять рабочими процессами в нашей системе. Мы часто обнаруживаем, слушая наших экспертов в предметной области, что они выражают требования причинным или временным образом - например, «Когда мы пытаемся распределить запасы, но их нет в наличии, мы должны отправить электронное письмо отделу снабжения».

Волшебные слова "When X, then Y" часто говорят нам о событии, которое мы можем сделать конкретным в нашей системе. Рассматривая события как first-class вещи в нашей модели, мы делаем наш код более тестируемым и наблюдаемым, а также изолируем проблемы.

((("message bus", "pros and cons or trade-offs")))
((("events and the message bus", "pros and cons or trade-offs")))
И <<chapter_08_events_and_message_bus_tradeoffs>> показывает компромиссы, как мы их видим.

[[chapter_08_events_and_message_bus_tradeoffs]]
[options="header"]
.Domain events: компромиссы
|===
|Плюсы|Минусы
a|
* Шина сообщений (message bus) дает нам хороший способ разделить обязанности, когда мы должны предпринять несколько действий в ответ на запрос.

* Обработчики событий (Event handlers) хорошо отделены от "основной" логики приложения, что позволяет легко изменить их реализацию позже.

* Доменные события (Domain events) -- это отличный способ моделирования реального мира, и мы можем использовать их как часть нашего делового языка при моделировании с заинтересованными сторонами.

a|

* Шина сообщений -- это еще одна вещь, которая кружит вам голову. Реализация, в которой единица работы вызывает для нас события, может это  _изящно_  и волшебно. Но, когда мы вызываем `commit`, не очевидно, что мы также собираемся отправить электронное письмо людям.

* Более того, этот скрытый код обработки событий выполняется _synchronously_, что означает, что ваша функция уровня сервиса не завершится до тех пор, пока не будут завершены все обработчики для любых событий. Это может привести к неожиданным проблемам с производительностью в ваших web endpoints
  (adding asynchronous processing is possible but makes things even _more_ confusing).
  ((("synchronous execution of event-handling code")))

* В более общем плане, управляемые событиями рабочие процессы могут сбивать с толку, потому что после того, как вещи разделены по цепочке из нескольких обработчиков, в системе нет единого места, где вы могли бы понять, как будет выполняться запрос.

* Вы также открываете для себя возможность возникновения циклических зависимостей между вашими обработчиками событий и бесконечными циклами.
  ((("dependencies", "circular dependencies between event handlers")))
  ((("events and the message bus", startref="ix_evntMB")))

a|
|===

((("aggregates", "changing multiple aggregates in a request")))
Однако события полезны не только для отправки электронной почты. В <<chapter_07_aggregate>> мы потратили много времени, убеждая вас, что вы должны определить агрегаты или границы, где мы гарантируем согласованность. Люди часто спрашивают: "Что мне делать, если мне нужно изменить несколько агрегатов в рамках запроса?" Теперь у нас есть инструменты, необходимые для ответа на этот вопрос.

Если у нас есть две вещи, которые могут быть транзакционно изолированы (например, заказ и [.keep-together]#product#), то мы можем сделать их _eventually consistent_ (в конечном итоге согласованными) с помощью событий. Когда заказ отменяется, мы должны найти продукты, которые были ему назначены, и удалить [.keep-together]#allocations#.

[role="nobreakinside less_space"]
.Обзор Событий домена и шины сообщений
*****************************************************************
((("events and the message bus", "domain events and message bus recap")))
((("message bus", "recap")))

События способствуют реализации принципа единой ответственности:: 
	Код запутывается, когда мы смешиваем несколько задач в одном месте. События могут помочь нам поддерживать порядок, отделяя основные варианты использования от второстепенных. Мы также используем события для связи между агрегатами, поэтому нам не нужно запускать длительные транзакции, которые блокируются для нескольких таблиц.

Шина сообщений направляет сообщения обработчикам::
    Вы можете думать о шине сообщений как о словаре, который сопоставляет события (events) с их потребителями(consumers). Словарь ничего не "знает" о смысле событий; это просто кусок тупой инфраструктуры для передачи сообщений по всей системе.

Вариант 1: Уровень сервиса вызывает события и передает их в шину сообщений::
    Самый простой способ начать использовать события в вашей системе-это вызвать их из обработчиков, вызвав `bus.handle(some_new_event)` после того, как вы зафиксируете свою единицу работы.
    ((("service layer", "raising events and passing them to message bus")))

Вариант 2: Доменная модель вызывает события, сервисный уровень передает их в шину сообщений::
    Логика того, когда поднимать событие, действительно должна жить с моделью, таким образом, мы можем улучшить дизайн и тестируемость нашей системы, подняв события из модели предметной области. Наши обработчики легко собирают события с объектов модели после `commit` "фиксации" и передают их в шину.
    ((("domain model", "raising events and service layer passing them to message bus")))

Вариант 3: UoW собирает события из агрегатов и передает их в шину сообщений::
    Добавление bus.handle (aggregate.events) к каждому обработчику раздражает, поэтому мы можем прибраться, сделав нашу единицу работы ответственной за создание событий, которые были вызваны загруженными объектами. Это наиболее сложный дизайн, и он может полагаться на магию ORM, но после настройки он понятен и прост в использовании.
    ((("aggregates", "UoW collecting events from and passing them to message bus")))
    ((("Unit of Work pattern", "UoW collecting events from aggregates and passing them to message bus")))

*****************************************************************

В <<chapter_09_all_messagebus>> мы рассмотрим эту идею более подробно при построении более сложного рабочего процесса с нашей новой шиной сообщений.
