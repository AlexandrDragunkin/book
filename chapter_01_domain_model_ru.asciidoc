[[chapter_01_domain_model]]
== Domain Modeling

((("domain modeling", id="ix_dommod")))
((("domain driven design (DDD)", seealso="domain model; domain modeling")))
В этой главе рассматривается, как можно моделировать бизнес-процессы с помощью кода таким образом, чтобы он был полностью совместим с TDD (Test Driven Development).  Обсудим, почему моделирование домена имеет значение, и рассмотрим несколько ключевых шаблонов для моделирования доменов: Entity, Value Object, и Domain Service.

<<maps_chapter_01_notext>> это простое визуальное представление для нашего шаблона Domain Model. В этой главе мы расскажем о некоторых деталях, а когда перейдем к другим главам, то построим все вокруг Domain Model, но вы всегда должны быть в состоянии найти эти маленькие формы в центре.

[[maps_chapter_01_notext]]
.Иллюстрация прототипа нашей модели предметной области (Domain Model)
image::images/apwp_0101.png[]

[role="pagebreak-before less_space"]
=== Что такое Domain Model?

((("business logic layer")))
В <<introduction, introduction>> мы использовали термин _business logic layer_ для описания центрального слоя трехслойной архитектуры. Для остальной части книги будем использовать термин _domain model_. Это термин из методологии Domain Driven Design (DDD), который лучше улавливает наш предполагаемый смысл (подробнее о DDD читайте дальше).

((("domain driven design (DDD)", "domain, defined")))
_domain_ -- причудливый способ обозначить _проблему, которую вы пытаетесь решить._
В настоящее время ваши авторы работают в мебельном интернет-магазине.  В зависимости от того, о какой системе вы говорите, предметной областью может быть совершение разовых покупок и закупка по долгосрочным договорам, дизайн продукта или логистика и доставка. Большинство программистов проводят свои дни в попытках улучшить или автоматизировать бизнес-процессы; домен является набором действий, которые поддерживают эти процессы.

((("model (domain)")))
_model_ -- карта процесса или явления, которая фиксирует полезное свойство.
Люди исключительно хороши в производстве моделей вещей в их головах. Например, когда кто-то бросает в вас мяч, вы можете предсказать его движение почти бессознательно, потому что у вас есть модель движения объектов в пространстве. Ваша модель ни в коем случае не идеальна. У людей есть ужасные интуитивные представления о том, как объекты ведут себя на околосветовых скоростях или в вакууме, потому что наша модель никогда не предназначалась для этих случаев. Это не означает, что модель неверна, но это означает, что некоторые прогнозы выходят за рамки её области.

Модель предметной области-это ментальная карта, которую владельцы бизнеса имеют о своем бизнесе. У всех деловых людей есть эти ментальные карты-это то, как люди думают о сложных процессах.

Вы можете сказать, когда они ориентируются по этим картам, потому что они используют деловой язык.
Жаргон возникает естественным образом среди людей, которые сотрудничают в сложных системах.

Представьте себе, что вы, наш несчастный читатель, внезапно перенеслись за много световых лет от Земли на борту инопланетного космического корабля со своими друзьями и семьей и должны выяснить, исходя из первых принципов, как вернуться домой.

В первые несколько дней вы наверное будете просто нажимать кнопки случайным образом, но вскоре разберётесь, какие кнопки что делают и сможете давать друг другу инструкции. "Нажми красную кнопку возле мигающей штуковины, а затем пребрось этот большой рычаг рядом с радарной хреновиной", -- скажете вы.

Через пару недель вы станете более точными, определив слова для описания функций корабля: "Увеличить уровень кислорода в третьем грузовом отсеке" или "включите дополнительные двигатели." Через несколько месяцев вы бы придумали язык для целых сложных процессов: "Начать программу посадки " или "приготовиться к перегрузке." Этот процесс происходил бы совершенно естественно, без каких-либо формальных усилий по созданию общего глоссария.

[role="nobreakinside less_space"]
.Это не книга DDD. Вам следует прочитать книгу DDD.
*****************************************************************

Domain-driven design, или же DDD, популяризировал концепцию моделирования предметной области,footnote:[ DDD не был инициатором моделирования предметной области. Эрик Эванс ссылается на книгу 2002 года _Object Design_ за авторством Rebecca Wirfs-Brock и Alan McKean  (Addison-Wesley Professional), который ввел дизайн, основанный на ответственности, из которых DDD является частным случаем, связанным с доменом. Но даже это слишком поздно, и энтузиасты ОО скажут вам, чтобы вы посмотрели дальше назад на Ивара Якобсона и Грейди Буча; этот термин существует с середины 1980-х годов.((("domain driven design (DDD)")))]
и это было чрезвычайно успешное движение в изменении способа разработки программного обеспечения, сосредоточенного на основной сфере бизнеса. Многие из шаблонов архитектуры, которые мы рассматриваем в этой книге, включая Entity, Aggregate, Value Object (см. <<chapter_07_aggregate>>), and Repository (в
<<chapter_02_repository,the next chapter>>) —- происходят из традиции DDD.

Короче говоря, DDD говорит, что самое важное в программном обеспечении -- это то, что оно предоставляет полезную модель проблемы. Если мы правильно воспользуемся этой моделью, наше программное обеспечение принесет пользу и сделает возможным новые вещи.

Если мы ошибаемся в модели, это становится препятствием, над которым нужно работать. В этой книге мы можем показать основы построения модели предметной области и построения на её основе архитектуры, которая максимально освобождает модель от внешних ограничений, чтобы её было легко развить и изменить.

Но в DDD и в процессах, инструментах и методах разработки модели предметной области есть гораздо больше. Тем не менее, мы надеемся дать вам почувствовать это на вкус и в достаточной мере побудить вас продолжить и прочитать соответствующую книгу DDD:

* The original "blue book," _Domain-Driven Design_ by Eric Evans (Addison-Wesley Professional)
* The "red book," _Implementing Domain-Driven Design_
  by Vaughn Vernon (Addison-Wesley Professional)

*****************************************************************

Так и в обычном мире бизнеса. Терминология, используемая заинтересованными сторонами бизнеса, представляет собой дистиллированное понимание модели предметной области, где сложные идеи и процессы сводятся к одному слову или фразе.

Когда мы слышим, как наши деловые партнеры используют незнакомые слова или используют термины определенным образом, мы должны слушать, чтобы понять более глубокий смысл и закодировать их с трудом завоеванный опыт в наше программное обеспечение.

В этой книге мы будем использовать модель предметной области реального мира, в частности модель из нашей текущей работы. MADE.com является успешным мебельным ритейлером. Мы поставляем нашу мебель от производителей по всему миру и продаем её по всей Европе.

Когда вы покупаете диван или журнальный столик, мы должны решить, как лучше всего доставить ваш товар из Польши, Китая или Вьетнама в вашу гостиную.

На высоком уровне у нас есть отдельные системы, которые отвечают за покупку акций, продажу акций клиентам и доставку товаров клиентам. Система в середине должна координировать процесс, распределяя запасы по заказам клиента; см. <<allocation_context_diagram>>.

[[allocation_context_diagram]]
.Контекстная диаграмма для службы распределения
image::images/apwp_0102ru.png[]
[role="image-source"]
----
[plantuml, apwp_0102]
@startuml Allocation Context Diagram
!include images/C4_Context.puml
scale 2

System(systema, "Allocation", "Распределяет запасы по заказам клиентов")

Person(customer, "Customer", "Хочет купить мебель")
Person(buyer, "Buying Team", "Потребности в покупке мебели у поставщиков")

System(procurement, "Purchasing" Совершение закупок
, "Manages workflow for buying stock from suppliers") Управляет рабочим процессом покупки запасов у поставщиков
System(ecom, "Ecommerce", "Sells goods online") Продает товары онлайн
System(warehouse, "Warehouse", "Manages workflow for shipping goods to customers") Управляет рабочим процессом доставки товаров покупателям

Rel(buyer, procurement, "Uses") Заявка
Rel(procurement, systema, "Notifies about shipments") Уведомляет о доставке
Rel(customer, ecom, "Buys from") Покупает у
Rel(ecom, systema, "Asks for stock levels") Запрашивает уровень запасов
Rel(ecom, systema, "Notifies about orders") Уведомляет о заказах
Rel_R(systema, warehouse, "Sends instructions to") Отправляет инструкции
Rel_U(warehouse, customer, "Dispatches goods to") Отправляет товар в

@enduml
----

В рамках этой книги, пофантазируем, что фирма решает внедрить новый способ распределения запасов.  До сих пор компания представляла товар и время выполнения заказа на основе того, что физически доступно на складе.  Если и вдруг склад пустеет, продукт считается "отсутствующим на складе" до тех пор, пока не поступит следующая партия от производителя.

Новая идея такова: если у нас есть система, которая может отслеживать все наши поставки и когда они должны прибыть, мы можем рассматривать товары на этих кораблях как реальные запасы и часть нашего инвентаря, просто с немного более длительным временем выполнения заказа. Не смотря на небольшие складские запасы, продавать будем больше, а бизнес сможет сэкономить деньги, уменьшив запасы на внутреннем складе.

Но распределение заказов больше не является тривиальным вопросом уменьшения одного количества в складской системе. Нам нужен более сложный механизм распределения. Время для некоторого моделирования предметной области.


=== Изучение языка предметной области

((("domain language")))
((("domain modeling", "domain language")))
Понимание модели предметной области требует времени, терпения и заметок. Мы предварительно беседуем с нашими бизнес-экспертами и договариваемся о глоссарии и некоторых правилах для первой минимальной версии модели предметной области. Там, где это возможно, мы просим привести конкретные примеры, иллюстрирующие каждое правило.

Мы уверены, чтобы выразить эти правила на бизнес-жаргоне (на _ubiquitous language_ в DDD терминологии) надо выбрать запоминающиеся идентификаторы для наших объектов, чтобы было легче говорить на примерах.

<<allocation_notes, следующий сайдбар>> показывает некоторые заметки, которые мы могли бы сделать во время разговора с нашими экспертами по предметной области Распределения.

[[allocation_notes]]
.Некоторые примечания по распределению
****
_product_ идентифицируется с помощью _SKU_, произносится как "skew", что является сокращением от _stock-keeping unit (единицы складского учета )_. _Customers_ место _orders_. Заказ идентифицируется ссылкой _order reference_ и содержит несколько  _order lines_, где каждая строка имеет _SKU_ и _quantity_. Например:

- 10 единиц RED-CHAIR
- 1 единица TASTELESS-LAMP

Отдел закупок заказывает небольшие партии товара. У _batch (партий)_ заказов есть уникальный идентификатор, называемый _reference (ссылка)_, _SKU_ и _quantity (количество)_.

Нам нужно _allocate (распределить)_ _order lines (позиции заказа)_ по _batches (партиям отгрузки)_. Когда мы выделили строку заказа для партии, мы отправим запас из этой конкретной партии поставки на адрес доставки клиента. Когда мы распределяем _x_ единиц запаса на партию, _available quantity (доступное количество)_ уменьшается на _x_. Например:

- У нас есть партия поставки 20 SMALL-TABLE, и мы выделяем строку заказа для 2 SMALL-TABLE.

- В партии поставки должно остаться 18 SMALL-TABLE.

Мы не можем отгрузить партию, если доступное количество меньше количества в строке заказа. Например:

- У нас есть партия 1 СИНЯЯ ПОДУШКА а строка заказа на 2 СИНЕЙ ПОДУШКИ.
- Мы не должны быть в состоянии выделить строку для партии отгрузки.

Мы не можем выделить одну и ту же линию дважды. Например:

- У нас есть партия поставки из 10 СИНИХ ВАЗ, и мы выделяем строку заказа для 2 СИНИХ ВАЗ.
- Если мы снова выделим строку заказа для той же партии, то партия все равно должна
иметь доступное количество 8.

Партии имеют _ETA_, если они в настоящее время отгружаются, или они могут быть на складе _warehouse_. Мы распределяем складские запасы в предпочтении к партиям отгрузки. Мы выделяем партии отгрузки, в которых указано самое раннее ETA.
****

=== Модульное тестирование доменных моделей

((("unit testing", "of domain models", id="ix_UTDM")))
((("domain modeling", "unit testing domain models", id="ix_dommodUT")))
Мы не собираемся показывать вам, как работает TDD в этой книге, но мы хотим показать вам, как мы могли бы построить модель из этого делового разговора.

[role="nobreakinside less_space"]
.Упражнение для читателя
******************************************************************************
Почему бы не попробовать решить эту проблему самостоятельно? Напишите несколько модульных тестов, чтобы увидеть, сможете ли вы уловить суть этих бизнес-правил в красивом, чистом коде.

Вы найдете некоторые https://github.com/cosmicpython/code/tree/chapter_01_domain_model_exercise[placeholder unit tests on GitHub], но вы можете просто начать с
нуля или объединить/переписать их так, как вам нравится.

//TODO: add test_cannot_allocate_same_line_twice ?
//(EJ3): nice to have for completeness, but not necessary

******************************************************************************

Вот как может выглядеть один из наших первых тестов:

[[first_test]]
.Первый тест на распределение (test_batches.py)
====
[source,python]
----
def test_allocating_to_a_batch_reduces_the_available_quantity():
    batch = Batch("batch-001", "SMALL-TABLE", qty=20, eta=date.today())
    line = OrderLine('order-ref', "SMALL-TABLE", 2)

    batch.allocate(line)

    assert batch.available_quantity == 18
----
====

Название нашего модульного теста описывает поведение, которое мы хотим получить от системы, а имена классов и переменных, которые мы используем, взяты из делового жаргона. Мы могли бы показать этот код нашим нетехническим коллегам, и они согласились бы, что это правильно описывает поведение системы.

[role="pagebreak-before"]
А вот и доменная модель, отвечающая нашим требованиям:

[[domain_model_1]]
.Первый заход доменной модели для партий (model.py)
====
[source,python]
[role="non-head"]
----
@dataclass(frozen=True)  #<1><2>
class OrderLine:
    orderid: str
    sku: str
    qty: int


class Batch:
    def __init__(
        self, ref: str, sku: str, qty: int, eta: Optional[date]  #<2>
    ):
        self.reference = ref
        self.sku = sku
        self.eta = eta
        self.available_quantity = qty

    def allocate(self, line: OrderLine):
        self.available_quantity -= line.qty  #<3>
----
====

<1> `OrderLine` это неизменяемый класс данных без какого-либо поведения.footnote:[В предыдущих версиях Python мы могли использовать именованный кортеж (namedtuple). Вы также можете ознакомиться с отличными предложениями Hynek Schlawack. https://pypi.org/project/attrs[attrs].]

<2> Мы не показываем импорт в большинстве листингов кода, чтобы сохранить их в чистоте. Мы надеемся, что вы догадались, что это появилось здесь благодаря `from dataclasses import dataclass`; аналогично, typing.Optional и datetime.date. Если вы хотите что-то перепроверить, вы можете увидеть полный рабочий код для каждой главы в её ветке (например,
    https://github.com/python-leap/code/tree/chapter_01_domain_model[chapter_01_domain_model]).

<3> Аннотации типов по-прежнему вызывают споры в мире Python. Для моделей предметной области они иногда могут помочь прояснить или задокументировать ожидаемые аргументы, и люди с IDE часто благодарны за них. Вы можете решить, что цена, заплаченная с точки зрения удобочитаемости, слишком высока.     ((("type hints")))

Наша реализация здесь тривиальна: `Batch` просто обертывает целое число `available_quantity`, и мы уменьшаем это значение при выделении. Мы написали кучу кода только для того, чтобы вычесть одно число из другого, но мы надеемся, что моделирование нашего домена точно окупится off.footnote:[Или вы думаете, что кода недостаточно?  Как насчет какой-то проверки того, что SKU в `OrderLine` совпадает с `Batch.sku`?  Мы сохранили некоторые мысли о валидации для <<appendix_validation>>.]

Давайте напишем несколько новых неудачных тестов:


[[test_can_allocate]]
.Логика тестирования того, что мы можем выделить (test_batches.py)
====
[source,python]
----
def make_batch_and_line(sku, batch_qty, line_qty):
    return (
        Batch("batch-001", sku, batch_qty, eta=date.today()),
        OrderLine("order-123", sku, line_qty)
    )


def test_can_allocate_if_available_greater_than_required():
    large_batch, small_line = make_batch_and_line("ELEGANT-LAMP", 20, 2)
    assert large_batch.can_allocate(small_line)

def test_cannot_allocate_if_available_smaller_than_required():
    small_batch, large_line = make_batch_and_line("ELEGANT-LAMP", 2, 20)
    assert small_batch.can_allocate(large_line) is False

def test_can_allocate_if_available_equal_to_required():
    batch, line = make_batch_and_line("ELEGANT-LAMP", 2, 2)
    assert batch.can_allocate(line)

def test_cannot_allocate_if_skus_do_not_match():
    batch = Batch("batch-001", "UNCOMFORTABLE-CHAIR", 100, eta=None)
    different_sku_line = OrderLine("order-123", "EXPENSIVE-TOASTER", 10)
    assert batch.can_allocate(different_sku_line) is False
----
====

Здесь нет ничего неожиданного. Мы переработали наш набор тестов, чтобы не повторять одни и те же строки кода для создания пакета и строки для одного и того же SKU; и мы написали четыре простых теста для нового метода `can_allocate`. Again, notice that the names we use mirror the language of our domain experts, and the examples we agreed upon are directly written into code.

Мы также можем реализовать это напрямую, написав `can_allocate`
метод `Batch`:


[[can_allocate]]
.Новый метод в модели (model.py)
====
[source,python]
----
    def can_allocate(self, line: OrderLine) -> bool:
        return self.sku == line.sku and self.available_quantity >= line.qty
----
====

Пока что мы можем управлять реализацией, просто увеличивая и уменьшая `Batch.available_quantity`, но когда мы перейдем к тестам `deallocate()`, мы будем вынуждены перейти к более интеллектуальному решению:

[role="pagebreak-before"]
[[test_deallocate_unallocated]]
.Этот тест потребует более умной модели (test_batches.py)
====
[source,python]
----
def test_can_only_deallocate_allocated_lines():
    batch, unallocated_line = make_batch_and_line("DECORATIVE-TRINKET", 20, 2)
    batch.deallocate(unallocated_line)
    assert batch.available_quantity == 20
----
====

В этом тесте мы assert-им, что deallocating (освобождение) строки из пакета не имеет никакого эффекта, если только пакет ранее не allocated (резервировал) эту строку. Чтобы это сработало, наша `Batch` должна понять, какие строки были зарезервированы. Давайте посмотрим на реализацию:


[[domain_model_complete]]
.Модель предметной области теперь отслеживает распределения (model.py)
====
[source,python]
[role="non-head"]
----
class Batch:
    def __init__(
        self, ref: str, sku: str, qty: int, eta: Optional[date]
    ):
        self.reference = ref
        self.sku = sku
        self.eta = eta
        self._purchased_quantity = qty
        self._allocations = set()  # type: Set[OrderLine]

    def allocate(self, line: OrderLine):
        if self.can_allocate(line):
            self._allocations.add(line)

    def deallocate(self, line: OrderLine):
        if line in self._allocations:
            self._allocations.remove(line)

    @property
    def allocated_quantity(self) -> int:
        return sum(line.qty for line in self._allocations)

    @property
    def available_quantity(self) -> int:
        return self._purchased_quantity - self.allocated_quantity

    def can_allocate(self, line: OrderLine) -> bool:
        return self.sku == line.sku and self.available_quantity >= line.qty

----
====

// TODO: consider a diff here
// TODO explain why harry refuses to use the inline type hints syntax

<<model_diagram>> показывает модель в UML.


[[model_diagram]]
.Our model in UML
image::images/apwp_0103.png[]
[role="image-source"]
----
[plantuml, apwp_0103, config=plantuml.cfg]
@startuml
scale 4

left to right direction
hide empty members

class Batch {
    reference
    sku
    eta
    _purchased_quantity
    _allocations
}

class OrderLine {
    orderid
    sku
    qty
}

Batch::_allocations o-- OrderLine
----


Теперь мы кое-чего добились! Пакет теперь отслеживает набор выделенных(allocated) объектов `OrderLine`. Когда мы распределяем (allocate), если у нас достаточно свободного количества(available quantity), мы просто добавляем к набору. Наше `available_quantity` теперь является вычисляемым свойством: купленное количество минус выделенное количество.

Да, мы могли бы сделать еще много. Немного обескураживает то, что и `allocate()`, и `deallocate()` могут потерпеть неудачу без предупреждения, но основа у нас теперь есть.

Кстати, использование набора для `._allocations` упрощает нам обработку последнего теста, потому что элементы в наборе уникальны:


[[last_test]]
.Last batch test!  (test_batches.py)
====
[source,python]
----
def test_allocation_is_idempotent():
    batch, line = make_batch_and_line("ANGULAR-DESK", 20, 2)
    batch.allocate(line)
    batch.allocate(line)
    assert batch.available_quantity == 18
----
====

На данный момент, вероятно, будет обоснованной критикой сказать, что модель предметной области слишком тривиальна, чтобы беспокоиться о DDD (или даже об объектной ориентации!). В реальной жизни возникает множество бизнес-правил и крайних случаев: клиенты могут запросить доставку в определенные будущие даты, а это означает, что мы можем не захотеть распределять их на самую раннюю партию. Некоторые SKU (артикулы) не выпускаются партиями, а заказываются по требованию непосредственно у поставщиков, поэтому у них другая логика. В зависимости от местоположения клиента мы можем выделить только подмножество складов и отгрузок, которые находятся в его регионе, за исключением некоторых SKU, которые мы с удовольствием доставляем со склада в другом регионе, если у нас нет запасов в домашнем регионе. And so on.  Настоящий бизнес в реальном мире знает, как нагромождать сложности быстрее, чем мы можем показать на странице!

Но взяв эту простую модель предметной области в качестве заменителя чего-то более сложного, мы расширим нашу простую модель предметной области в остальной части книги и подключим её к реальному миру API, баз данных и электронных таблиц. Мы увидим, как строгое следование нашим принципам инкапсуляции и тщательного наслоения поможет нам избежать комка грязи.


[role="nobreakinside"]
.Больше типов для большего числа аннотаций
*******************************************************************************

((("type hints")))
Если вы действительно хотите отправиться в город с подсказками типа, вы можете зайти так далеко, что обернете примитивные типы с помощью `typing.NewType`:

[[too_many_types]]
.Просто зашел слишком далеко, Боб
====
[source,python]
[role="skip"]
----
from dataclasses import dataclass
from typing import NewType

Quantity = NewType("Quantity", int)
Sku = NewType("Sku", str)
Reference = NewType("Reference", str)
...

class Batch:
    def __init__(self, ref: Reference, sku: Sku, qty: Quantity):
        self.sku = sku
        self.reference = ref
        self._purchased_quantity = qty
----
====


Это позволило бы нашей проверке типов убедиться, что мы не передаем `Sku`, где ожидается, например, `Reference (Ссылка)`.

Считаете ли вы это замечательным или ужасным-вопрос спорный.footnote:[Это ужасно.  Пожалуйста, пожалуйста, не делай этого. —Harry]

*******************************************************************************

==== Dataclasses отлично подходят для Value Objects

((("value objects", "using dataclasses for")))
((("dataclasses", "use for value objects")))
((("domain modeling", "unit testing domain models", "dataclasses for value objects")))
Мы широко использовали `line` в предыдущих листингах кода, но что такое строка? На нашем деловом языке _order_ состоит из нескольких _line_ товаров, где каждая строка имеет SKU и количество. Мы можем представить, что простой файл YAML, содержащий информацию о заказе, может выглядеть так:


[[yaml_order_example]]
.Информация о заказе как YAML
====
[source,yaml]
[role="skip"]
----
Order_reference: 12345
Lines:
  - sku: RED-CHAIR
    qty: 25
  - sku: BLU-CHAIR
    qty: 25
  - sku: GRN-CHAIR
    qty: 25
----
====



Обратите внимание, что в то время как заказ имеет _reference_, который однозначно идентифицирует его, _line_ нет. (Даже если мы добавим ссылку на порядок в класс OrderLine, это не то, что однозначно идентифицирует саму строку.)

((("value objects", "defined")))
Всякий раз, когда у нас есть бизнес-концепция, имеющая данные, но не имеющая идентичности, мы часто предпочитаем представлять её с помощью шаблона _Value Object_. _value object_-это любой объект предметной области, который однозначно идентифицируется содержащимися в нем данными; обычно мы делаем их неизменяемыми:

// [SG] seems a bit odd to hear about value objects before any mention of entities.

[[orderline_value_object]]
.OrderLine как value object
====
[source,python]
[role="skip"]
----
@dataclass(frozen=True)
class OrderLine:
    orderid: OrderReference
    sku: ProductReference
    qty: Quantity
----
====

((("namedtuples", seealso="dataclasses")))
Одна из приятных вещей, которые дают нам dataclasses (или namedtuples), -- это _value equality_, что является причудливым способом сказать: "Две строки с одинаковыми `orderid`, `sku` и `qty` равны."


[[more_value_objects]]
.Еще примеры value objects
====
[source,python]
[role="skip"]
----
from dataclasses import dataclass
from typing import NamedTuple
from collections import namedtuple

@dataclass(frozen=True)
class Name:
    first_name: str
    surname: str

class Money(NamedTuple):
    currency: str
    value: int

Line = namedtuple('Line', ['sku', 'qty'])

def test_equality():
    assert Money('gbp', 10) == Money('gbp', 10)
    assert Name('Harry', 'Percival') != Name('Bob', 'Gregory')
    assert Line('RED-CHAIR', 5) == Line('RED-CHAIR', 5)
----
====

((("value objects", "math with")))
Эти ценностные объекты соответствуют нашей реальной интуиции о том, как работают их ценности. Не имеет значения, о какой банкноте в 10 фунтов мы говорим, потому что все они имеют одинаковую ценность. Аналогично, два имени равны, если совпадают имя и фамилия; и две строки эквивалентны, если они имеют один и тот же заказ клиента, код продукта и количество. Однако мы все еще можем иметь сложное поведение на ценностном объекте. На самом деле, обычно поддерживают операции со значениями; например, математические операторы:


[[value_object_maths]]
.Математика с value objects
====
[source,python]
[role="skip"]
----
fiver = Money('gbp', 5)
tenner = Money('gbp', 10)

def can_add_money_values_for_the_same_currency():
    assert fiver + fiver == tenner

def can_subtract_money_values():
    assert tenner - fiver == fiver

def adding_different_currencies_fails():
    with pytest.raises(ValueError):
        Money('usd', 10) + Money('gbp', 10)

def can_multiply_money_by_a_number():
    assert fiver * 5 == Money('gbp', 25)

def multiplying_two_money_values_is_an_error():
    with pytest.raises(TypeError):
        tenner * fiver
----
====




==== Value Objects и Entities

((("value objects", "and entities", secondary-sortas="entities")))
((("domain modeling", "unit testing domain models", "value objects and entities")))
Строка заказа однозначно идентифицируется по идентификатору заказа, артикулу и количеству; если мы изменим одно из этих значений, теперь у нас будет новая строка. Это определение value object: любой объект, который идентифицируется только своими данными и не имеет долгоживущей идентичности. А как насчет партии? Это _is_ идентифицировано ссылкой.

((("entities", "defined")))
Мы используем термин _entity_ для описания объекта домена, который имеет долгосрочную идентичность. На предыдущей странице мы представили класс `Name` как объект значения. Если мы возьмем имя Гарри Персиваль и изменим одну букву, у нас будет новый объект `Name`, Барри Персиваль.

Должно быть ясно, что Гарри Персиваль не равен Барри Персивалю:


[[test_equality]]
.Само имя не может измениться ...
====
[source,python]
[role="skip"]
----
def test_name_equality():
    assert Name("Harry", "Percival") != Name("Barry", "Percival")
----
====


Но как насчет Гарри как личности? Люди меняют свои имена, семейное положение и даже пол, но мы продолжаем признавать их как одного человека. Это потому, что люди, в отличие от имен, имеют постоянное
_identity_:


[[person_identity]]
.Но человек может!
====
[source,python]
[role="skip"]
----
class Person:

    def __init__(self, name: Name):
        self.name = name


def test_barry_is_harry():
    harry = Person(Name("Harry", "Percival"))
    barry = harry

    barry.name = Name("Barry", "Percival")

    assert harry is barry and barry is harry
----
====



((("entities", "identity equality")))
((("identity equality (entities)")))
Сущности, в отличие от значений, обладают _identity equality (равенством идентичности)_. Мы можем изменить их ценности, и они по-прежнему узнаваемы. Batches (партии), в нашем примере, являются сущностями. Мы можем выделить строки для партии или изменить дату, когда мы ожидаем, что он прибудет, и это будет все та же сущность.

((("equality operators, implementing on entities")))
Обычно мы делаем это явно в коде, реализуя операторы равенства для сущностей:



[[equality_on_batches]]
.Реализация операторов равенства (model.py)
====
[source,python]
----
class Batch:
    ...

    def __eq__(self, other):
        if not isinstance(other, Batch):
            return False
        return other.reference == self.reference

    def __hash__(self):
        return hash(self.reference)
----
====

((("magic methods", "&#x5f;&#x5f;eq&#x5f;&#x5f;", secondary-sortas="eq")))
((("&#x5f;&#x5f;eq&#x5f;&#x5f;magic method", primary-sortas="eq")))
Магический метод Python +++ <code> __eq__ </code> +++
определяет поведение класса для `==` operator.footnote:[+++ <code> __eq__ </code> +++ произносится как "dunder-EQ". По крайней мере, некоторыми.]

((("magic methods", "&#x5f;&#x5f;hash&#x5f;&#x5f;", secondary-sortas="hash")))
((("&#x5f;&#x5f;hash&#x5f;&#x5f; magic method", primary-sortas="hash")))
И для объектов сущностей, и для объектов значений также стоит подумать о том, как +++ <code> __hash__ </code> +++ будет работать.  Это волшебный метод, который Python использует для управления поведением объектов, когда вы добавляете их в наборы или используете их как ключи dict; вы можете найти дополнительную информацию https://oreil.ly/YUzg5[в документации Python].

Для value objects хэш должен основываться на всех атрибутах value, и мы должны гарантировать, что объекты неизменяемы.  Мы получаем это бесплатно, указав `@frozen=True` в классе данных.

Для сущностей самый простой вариант-сказать, что хэш-это ++None++, что означает, что объект не является хэшируемым и не может, например, использоваться в наборе. Если по какой-то причине вы решите, что действительно хотите использовать операции set или dict с сущностями, хэш должен основываться на атрибуте(атрибутах), таком как `.reference`, который определяет уникальную идентичность сущности с течением времени. Вы должны также попытаться как-то сделать _этот_ атрибут read-only.

WARNING: This is tricky territory; you shouldn't modify +++<code>__hash__</code>+++
    without also modifying +++<code>__eq__</code>+++.  If you're not sure what
    you're doing, further reading is suggested.
    https://oreil.ly/vxkgX["Python Hashes and Equality"] by our tech reviewer
    Hynek Schlawack is a good place to start.
    ((("unit testing", "of domain models", startref="ix_UTDM")))
    ((("domain modeling", "unit testing domain models", startref="ix_dommodUT")))



=== Not Everything Has to Be an Object: A Domain Service Function

((("domain services")))
((("domain modeling", "functions for domain services", id="ix_dommodfnc")))
We've made a model to represent batches, but what we actually need
to do is allocate order lines against a specific set of batches that
represent all our stock.

[quote, Eric Evans, Domain-Driven Design]
____
Sometimes, it just isn't a thing.
____

((("service-layer services vs. domain services")))
Evans discusses the idea of Domain Service
operations that don't have a natural home in an entity or value
object.footnote:[Domain services are not the same thing as the services from
the <<chapter_04_service_layer,service layer>>, although they are
often closely related. A domain service represents a business concept or
process, whereas a service-layer service represents a use case for your
application. Often the service layer will call a domain service.] A
thing that allocates an order line, given a set of batches, sounds a lot like a
function, and we can take advantage of the fact that Python is a multiparadigm
language and just make it a function.
((("domain services", "function for")))

Let's see how we might test-drive such a function:


[[test_allocate]]
.Testing our domain service (test_allocate.py)
====
[source,python]
----
def test_prefers_current_stock_batches_to_shipments():
    in_stock_batch = Batch("in-stock-batch", "RETRO-CLOCK", 100, eta=None)
    shipment_batch = Batch("shipment-batch", "RETRO-CLOCK", 100, eta=tomorrow)
    line = OrderLine("oref", "RETRO-CLOCK", 10)

    allocate(line, [in_stock_batch, shipment_batch])

    assert in_stock_batch.available_quantity == 90
    assert shipment_batch.available_quantity == 100


def test_prefers_earlier_batches():
    earliest = Batch("speedy-batch", "MINIMALIST-SPOON", 100, eta=today)
    medium = Batch("normal-batch", "MINIMALIST-SPOON", 100, eta=tomorrow)
    latest = Batch("slow-batch", "MINIMALIST-SPOON", 100, eta=later)
    line = OrderLine("order1", "MINIMALIST-SPOON", 10)

    allocate(line, [medium, earliest, latest])

    assert earliest.available_quantity == 90
    assert medium.available_quantity == 100
    assert latest.available_quantity == 100


def test_returns_allocated_batch_ref():
    in_stock_batch = Batch("in-stock-batch-ref", "HIGHBROW-POSTER", 100, eta=None)
    shipment_batch = Batch("shipment-batch-ref", "HIGHBROW-POSTER", 100, eta=tomorrow)
    line = OrderLine("oref", "HIGHBROW-POSTER", 10)
    allocation = allocate(line, [in_stock_batch, shipment_batch])
    assert allocation == in_stock_batch.reference
----
====

((("functions", "for domain services")))
And our service might look like this:


[[domain_service]]
.A standalone function for our domain service (model.py)
====
[source,python]
[role="non-head"]
----
def allocate(line: OrderLine, batches: List[Batch]) -> str:
    batch = next(
        b for b in sorted(batches) if b.can_allocate(line)
    )
    batch.allocate(line)
    return batch.reference
----
====

==== Python's Magic Methods Let Us Use Our Models with Idiomatic Python

((("&#x5f;&#x5f;gt&#x5f;&#x5f; magic method", primary-sortas="gt")))
((("magic methods", "allowing use of domain model with idiomatic Python")))
You may or may not like the use of `next()` in the preceding code, but we're pretty
sure you'll agree that being able to use `sorted()` on our list of
batches is nice, idiomatic Python.

To make it work, we implement +++<code>__gt__</code>+++ on our domain model:



[[dunder_gt]]
.Magic methods can express domain semantics (model.py)
====
[source,python]
----
class Batch:
    ...

    def __gt__(self, other):
        if self.eta is None:
            return False
        if other.eta is None:
            return True
        return self.eta > other.eta
----
====

That's lovely.


==== Exceptions Can Express Domain Concepts Too

((("domain exceptions")))
((("exceptions", "expressing domain concepts")))
We have one final concept to cover: exceptions can be used to express domain
concepts too. In our conversations with domain experts, we've learned about the
possibility that an order cannot be allocated because we are _out of stock_,
and we can capture that by using a _domain exception_:


[[test_out_of_stock]]
.Testing out-of-stock exception (test_allocate.py)
====
[source,python]
----
def test_raises_out_of_stock_exception_if_cannot_allocate():
    batch = Batch('batch1', 'SMALL-FORK', 10, eta=today)
    allocate(OrderLine('order1', 'SMALL-FORK', 10), [batch])

    with pytest.raises(OutOfStock, match='SMALL-FORK'):
        allocate(OrderLine('order2', 'SMALL-FORK', 1), [batch])
----
====


[role="nobreakinside"]
.Domain Modeling Recap
*****************************************************************
Domain modeling::
    This is the part of your code that is closest to the business,
    the most likely to change, and the place where you deliver the
    most value to the business. Make it easy to understand and modify.
    ((("domain modeling", startref="ix_dommod")))

Distinguish entities from value objects::
    A value object is defined by its attributes. It's usually best
    implemented as an immutable type. If you change an attribute on
    a Value Object, it represents a different object. In contrast,
    an entity has attributes that may vary over time and it will still be the
    same entity. It's important to define what _does_ uniquely identify
    an entity (usually some sort of name or reference field).
    ((("entities", "value objects versus")))
    ((("value objects", "entities versus")))

Not everything has to be an object::
    Python is a multiparadigm language, so let the "verbs" in your
    code be functions. For every `FooManager`, `BarBuilder`, or `BazFactory`,
    there's often a more expressive and readable `manage_foo()`, `build_bar()`,
    or `get_baz()` waiting to happen.
    ((("functions")))

This is the time to apply your best OO design principles::
    Revisit the SOLID principles and all the other good heuristics like "has a versus is-a,"
    "prefer composition over inheritance," and so on.
    ((("object-oriented design principles")))

You'll also want to think about consistency boundaries and aggregates::
    But that's a topic for <<chapter_07_aggregate>>.

*****************************************************************

We won't bore you too much with the implementation, but the main thing
to note is that we take care in naming our exceptions in the ubiquitous
language, just as we do our entities, value objects, and services:


[[out_of_stock]]
.Raising a domain exception (model.py)
====
[source,python]
----
class OutOfStock(Exception):
    pass


def allocate(line: OrderLine, batches: List[Batch]) -> str:
    try:
        batch = next(
        ...
    except StopIteration:
        raise OutOfStock(f'Out of stock for sku {line.sku}')
----
====


<<maps_chapter_01_withtext>> is a visual representation of where we've ended up.

[[maps_chapter_01_withtext]]
.Our domain model at the end of the chapter
image::images/apwp_0104.png[]

((("domain modeling", "functions for domain services", startref="ix_dommodfnc")))
That'll probably do for now! We have a domain service that we can use for our
first use case. But first we'll need a database...
